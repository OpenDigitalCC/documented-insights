Ref. Ares(2026)214810 - 09/01/2026

                  Sovereign System

  Privacy-preserving identity protocol employing zero-knowledge
technology and decentralized identifiers for secure self-custody and
        user-owned data across distributed ledger networks

Douglas Broughton, Mehmet Kiraz, Foteinos Mergoupis-Anagnou,
           Kadir Pekel, Gwin Scott, Cristiaan Brans

                       Friday 14th July, 2023

                  V1.1 Ã‚Â©2023 VENDIBLE (BVI) INC

          https://www.vendiblelabs.com/, info@vendiblelabs.com
                                             Sovereign System

Contents

1 Introduction                                                                                             1
     1.1   Innovation vs Technology Adaptation . . . . . . . . . . . . . . . . . . . . . . . .             1
     1.2   Custodial solutions vs Self-Custody . . . . . . . . . . . . . . . . . . . . . . . . .           3
     1.3   Motivation and Contributions: The Sovereign System . . . . . . . . . . . . . . .                4
     1.4   Roadmap      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .      4

2 Challenges Blocking Adoption of Permissionless Networks                                                  6
     2.1   Importance of Public Permissionless Networks           . . . . . . . . . . . . . . . . . . .    6
     2.2   Consumer Challenges . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .           7
     2.3   Institutional Challenges     . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .      9
     2.4   Closed Networks      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .      9

3 Other Issues and Trends                                                                                 11
     3.1   Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .       11
     3.2   Identity   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     11
     3.3   Privacy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .      12
     3.4   Decentralized Identier Ambiguity . . . . . . . . . . . . . . . . . . . . . . . . . .          12

4 Solution Overview                                                                                       13
     4.1   Sovereign System . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .         13
     4.2   General Assumptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .          15

5 Cryptographic Background                                                                                16
     5.1   Elliptic Curves    . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     16
     5.2   Hash Functions     . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     17
     5.3   Pedersen Commitment        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     17
     5.4   Threshold ElGamal Encryption         . . . . . . . . . . . . . . . . . . . . . . . . . . .     18
     5.5   Elliptic Curve Integrated Encryption Scheme (ECIES)              . . . . . . . . . . . . . .   21
     5.6   Digital Signatures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .       22
     5.7   Recommended Curve Sizes [MSS17], [BD18]              . . . . . . . . . . . . . . . . . . . .   30
     5.8   Ed25519 Clamping and Selection of Scalar to make compatible with JubJub                  . .   31

6 Honest-Verier Zero Knowledge (ÃŽÂ£-proofs)                                                                33
     6.1   Schnorr's Protocol: Proving the knowledge of r such that P = rG              . . . . . . . .   33
     6.2   Proving the equality of messages in dierent Pedersen Commitments                . . . . . .   34

ii
                                           Sovereign System

  6.3    Proof of Knowledge in a Pedersen Commitment              . . . . . . . . . . . . . . . . . .   35
  6.4    AND Composition of Schnorr's Protocol          . . . . . . . . . . . . . . . . . . . . . .     36
  6.5    Equality Composition of Schnorr's Protocol           . . . . . . . . . . . . . . . . . . . .   37
  6.6    Proving the Equality of the Secret Between JubJub and ed25519 . . . . . . . . .                39

7 Denitions for the Sovereign System                                                                   44
  7.1    Unique identication (uID) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .         44
  7.2    Main Account . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .         44
  7.3    Associated Account . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .         45
  7.4    Self Sovereign versus Sovereign versus Custody . . . . . . . . . . . . . . . . . . .           45

8 Merkle Tree and Authentication Path                                                                   46
9 Open Source Crypto Libraries for ZKSNARKs                                                             48
  9.1    Circuit Generation: Circom       . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     48
  9.2    Proof Generation & Verify . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .          48
  9.3    Communication: Use gRPC          . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     49
  9.4    Additional Tutorial & Documentations: . . . . . . . . . . . . . . . . . . . . . . .            49

10 The Sovereign System                                                                                 50
  10.1 Entities    . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .      50
  10.2 Trust Assumptions and Requirements . . . . . . . . . . . . . . . . . . . . . . . .               51
  10.3 Unique Identication (uID)         . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     54
  10.4 Registration and Creation of a Main DID Object               . . . . . . . . . . . . . . . . .   54

11 A Sovereign System Use Case: Encryption of a Private Key of Other Chains 64
  11.1 Login to Trustible . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .         64
  11.2 The Protocol for Secure Storage Keys of Other Chains               . . . . . . . . . . . . . .   65
  11.3 Recovery of Private Keys of Other Chains           . . . . . . . . . . . . . . . . . . . . .     69

12 Full Recovery of Main Accounts                                                                       71
  12.1   tsk is unknown     . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     71

13 Integration of Trustible with PolygonID                                                              78
  13.1 Creating a Claim for Polygon ID through Associated Accounts . . . . . . . . . .                  78

14 Restricting Associated Accounts for Dierent Application Domains                                     81
  14.1 A New Merkle Tree to Ensure One Associated Account for Each Main Account .                       81
  14.2 The Protocol       . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     81
  14.3 Revoking an Associated Account for an Application Domain                 . . . . . . . . . . .   85

15 Deactivating Main Accounts                                                                           86
  15.1 Case 1: If a user remembers his/her tsk . . . . . . . . . . . . . . . . . . . . . . .            86
  15.2 Case 2: If a user does not remember both tsk and the security answers                . . . . .   86

16 Potential Enhancements: Extending to Social Recovery                                                 87

                                                                                                        iii
                                           Sovereign System

17 Securing the Sovereign System                                                                      88
     17.1 Network Minimum Commitment . . . . . . . . . . . . . . . . . . . . . . . . . . .            88
     17.2 Cooperative Network . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .       88
     17.3 Member Staking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .      89
     17.4 Operational Rewards . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .       89

18 Expansion of the Sovereign System                                                                  90
     18.1 Identity Vault Questions Research . . . . . . . . . . . . . . . . . . . . . . . . . .       90
     18.2 Selective Disclosure and User-Owned Distributed Data          . . . . . . . . . . . . . .   90
     18.3 Automation of Associated Accounts . . . . . . . . . . . . . . . . . . . . . . . . .         91
     18.4 Specic Use Cases . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     91
     18.5 Variations of the Sovereign System      . . . . . . . . . . . . . . . . . . . . . . . . .   92

iv
                                      Sovereign System

                     DOCUMENT APPROVAL INFORMATION
       Approved by    VENDIBLE (BVI) INC

                                 CHANGE RECORDS
Version                 Reason                           Chapter                Date
 No
 1.0      The Sovereign System whitepaper has                 -              12 Dec 2022
                      been created.
 1.1       Correction of minor typos. New use      Typos correction in all   14 Apr 2023
                cases have been added.            chapters. Also, Chapter
                                                    13 and 14 have been
                                                           added.

                                                                                           v
                                        Sovereign System

Chapter 1
Introduction

1.1 Innovation vs Technology Adaptation
Blockchain technology allows participants to transact directly with peers without intermedi-
aries or custodians [Nak08]. The earliest adopters of this technology include technologists and
internet-savvy individuals who ideologically agree with the principles behind self-sovereignty
or self-custody. For most, however, self-custody is a technical burden with risks, complexities,
and costs that outweigh the current perceived benets. Without a new system for interacting
with decentralized technologies, this friction will keep most individuals from acceptance of the
technology without the assistance of custodians.
   Examining technology acceptance leads us to critical factors necessary for adopting dis-
tributed ledger technology. Rogers' Diusion of Innovations [RS71, Rog79, Rog, Rog03, Rog10]
(DOI) describes how new technologies gain acceptance in social systems. The rst users are
deemed innovators and acknowledge the practical advantages of a novel system over the per-
ceived costs. Innovators are often willing to interface with a new technology regardless of the
costs, as they are the rst to recognize a need for innovation. Innovators represent 2.5 percent
of the total market share, and their acceptance brings continued advancements that increase
the ease of interface and reduce perceived cost. With continued innovation comes the approval
of the Early Adopters, the next 13.5 percent of the market.      This adoption group generally
identies as technology enthusiasts, understands the value versus the cost, and accepts the
technology once the Innovators overcome the initial limitations. With continued technological
improvements, adopting new technologies follows an S-shape adoption curve, following Met-
calfe's law.
   As an adaptation of DOI, Moore [Moo22] has suggested a gap exists between Early Adopters
and the rest of the market. Described as a chasm, Moore implies that there is a tremendous
amount of friction that a technological movement must overcome in the early adoption cycle.
While primarily focused on product marketing, Moore's position is that the Innovators and
Early Majority have dierent expectations than the remaining adoption groups, even when
initially following the S-curve of adoption. While Rogers agreed [Rog03] that there are essential
dierences between adoption groups, Moore's chasm theory does not hold with Roger's DOI
results as he measured no recognized breaks in adoption between adjacent categories. Yet, a
technologies' failure to innovate to the point that it can meet the majority's expectations could

                                                                                               1
                                        Sovereign System

Figure 1.1:   Categories of adopters and adoption curve, based on Diusion of Innovations
(Rogers, 2003)

suggest why specic innovations fail to reach the masses while others succeed [RSF07].
    The Technology Acceptance Model [Lam22] (TAM) posits that a specic technology's per-
ceived usefulness and ease of use must outweigh the perceived eort required to adopt if that in-
novation is to be accepted. Costs in TAM can be monetary outow, physical exertion, and men-
tal eort. This model aligns with the Value-based Adoption Model [Lam22] (VAM), where the
benets, dened as usefulness and enjoyment, must outweigh the monetary and non-monetary
costs.
    All three models point to similar models for adoption. New technologies must have advan-
tages over previous systems and provide more value than incumbent technologies. They must
continually innovate and become easier to use so that the majority see more value in their
application than cost, thus becoming socially acceptable.    Once a great enough share of the
market perceives more benets than diculties, intentions to adopt convert into acceptance,
leading to a network eect that takes over a market.
    Public permissionless blockchains must continue to innovate until a tipping point, where
15 and 20 percent of the population accept the technology, to reach a level of social accep-
tance for that stated network eect to take hold and accelerate adoption through the Early
and Late Majority groups [Lam22]. While there has been a tremendous focus on technological
improvements, permissionless systems face challenges as incumbent technologies, such as pay-
ment systems, continue to innovate. Private permissioned blockchains, as well as the growing
number of service providers and applications that act as custodians for digital assets, also pose
risks to the sovereign model of permissionless systems.

2
                                        Sovereign System

1.2 Custodial solutions vs Self-Custody
Having custodians remove complexities helps aid adoption, and the acceptance of others helps
lead the majority to accept new technology [Rog03]. While custodians have their uses and will
play a signicant role in the use of blockchain technology, the current trends suggest that the
Early Majority, representing roughly 34 percent of the population, will interact with blockchain
technology primarily through the assistance of custodians. Current trends and adoption models
suggest they will follow this path because service providers oering custodial solutions oer the
net lowest cost compared to self-custody solutions. Custodians provide signicant reductions
in physical and mental eort compared to self-custody while perceptually portraying nearly the
same advantages as self-custody. While there are profound dierences in advantages between
custodial services and self-custody, they are perceived as insignicant by new entrants into the
market as, generally, they are more concerned with the function of a product rather than the
underlying structure or delivery of the product. For most, the importance of self-custody is a
foreign concept that requires a tremendous amount of physical and mental eort; more than
most wish to expend when so many other areas of their daily life require focus and eort.

   Businesses, institutions, and governments accept distributed ledger technology at an increas-
ing rate as they see process improvement and cost reduction advantages [Gar22]. Primarily,
these entities choose permissioned networks where the key stakeholders own the network nodes,
which provide consensus to control business logic tailored to a specic vertical or use case. As
businesses continue their acceptance and integrate this technology into their standard practices,
it will eventually lead to new product oerings on permissioned blockchains that will likely only
provide custodial oerings. For businesses, this choice to build on closed systems is evident as
they see clear advantages over public distributed ledger technology [Men18]. However, as use of
these permissioned blockchains continue to gain support for consumer product oerings, trends
suggest the Late Majority and Laggards will primarily, if not entirely, interface with blockchain
technology through custodians.

   Self-sovereign control over assets brings freedom. However, this freedom comes with many
technical complexities and risks making the barrier to entry and the burden of self-custody
high.   Custodians mitigate many of these risks and remove complexities at the expense of
some freedom as the custodian controls the ow of transactions and, in most cases, maintains
ownership of individuals' assets.

   The current adoption trends towards custodial solutions may lead to the negation of self-
custody and public blockchain systems. By public systems, we are referring to public permis-
sionless blockchains, which allow anyone to participate in the network (we will refer to these as
pubic blockchains, public systems, and public networks depending upon the context). Examples
of public networks include Bitcoin, Ethereum, Zcash, and Algorand. Public systems must also
incorporate ways to protect consumer data in transactions for widespread acceptance. Public
permissioned blockchains (such as Ripple and NEO) or private permissioned blockchains (such
as Hyperledger, Quorum, or a private Ethereum side-chain) already include dierent levels of
data protection. While transparency and traceability are crucial for trust in public blockchain
networks, seeking ways to protect sensitive data is necessary. Companies almost unanimously
choose public and private permissioned networks for data protection. Therefore, public systems
must also include consumer protections to gain a majority of acceptance in the market.

                                                                                               3
                                         Sovereign System

1.3 Motivation and Contributions: The Sovereign System
This paper presents a third option between self-sovereignty and custodians to address the
discussions in the previous section. We title this option   the Sovereign System. On a very high
level, the Sovereign System has the following features:

    Ã‚Âˆ It is rooted in identity and provides participants on public networks full ownership and
      control over their data and assets, with safeguards based on identity to ensure data
      protection.

    Ã‚Âˆ Further variations of this system ensure privacy preservation and compliance for individ-
      uals and institutions.

    Ã‚Âˆ The structure presented removes the complexities of self-custody while ensuring the par-
      ticipant always maintains full ownership of their assets and data.

    Ã‚Âˆ We have constructed this system to remove a signicant amount of cost with advantages
      for consumers and institutions so that sovereign control is a viable option for most users
      who have yet to enter the market.

1.4 Roadmap
The rest of the paper is as follows.

    Ã‚Âˆ In Chapter 2, we present the challenges which are blocking the mass adoption of permis-
      sionless networks.

    Ã‚Âˆ In Chapter 3, we present other issues such as data, identity, and privacy.

    Ã‚Âˆ In Chapter 4, we present the high-level solution of the Sovereign System and general
      assumptions.

    Ã‚Âˆ Chapter 5 presents the necessary cryptographic background.

    Ã‚Âˆ In Chapter 6, we present the ÃŽÂ£ protocols which are necessary to prove the correctness of
      calculations without disclosing the private information.

    Ã‚Âˆ Chapter 7 gives the basic denitions behind the Sovereign System.

    Ã‚Âˆ Chapter 8 revisits the Merkle Trees and Authentication Paths which are necessary to use
      the membership proofs.

    Ã‚Âˆ Chapter 9 presents the open source implementations of ZKSNARKs which are used in
      the Sovereign System.

    Ã‚Âˆ Chapter 10 introduces the architectural ow of the Sovereign System.

    Ã‚Âˆ In Chapter 12, we present the rst use case for the recovery of private keys of other chains.

4
                                    Sovereign System

Ã‚Âˆ Chapter 15 presents how a user can disable himself/herself.

Ã‚Âˆ Chapter 16 presents how it can be easily extended to social recovery, solving the long
  standing problem.

Ã‚Âˆ In Chapter 17, we present how to secure the Sovereign System further.

Ã‚Âˆ Finally, in Chapter 18, we present other potential and immediate use cases of the Sovereign
  System.

                                                                                           5
                                         Sovereign System

Chapter 2

Challenges Blocking Adoption of
Permissionless Networks

2.1 Importance of Public Permissionless Networks

From its inception with Bitcoin, the original intent of blockchain technology was to facilitate
a shift in ownership rights from centralized authorities directly to those interacting with the
network through a shared, decentralized ledger that was public, agreed upon, and tamper-
resistant. The importance of this technology cannot be understated; it provides a clear path to
sovereignty over one's assets, a rare opportunity in our modern nancial system. The shared
ledger also oers parties who do not know or trust one another security while transacting
through trustless mechanisms.

    Innovators and many Early Adopters recognized the value of owning and controlling one's
assets.   They embraced a solution to systemic issues of trust-based nancial systems that
routinely fail due to institutions' mismanagement of assets. To achieve the freedom outlined
by the Innovators, one must be comfortable assuming self-custody of one's assets. Blockchain
technology achieves self-custody through a secure private key generation (which can also be
represented by a passphrase), storage, and management. Digital assets on blockchain networks
exist as records on the distributed ledger, controlled by the private keys stored in wallets
and other devices by the owner. With possession of the private keys comes complete positive
control of the assets. When an individual or entity relies on a third party to secure their digital
assets, they give or transfer the ownership rights to that party, once again forming a trust-
based relationship and breaking the original intent of the technology.      Therefore, innovation
in managing private keys must continue so that sovereign control on public permissionless
networks continues to gain acceptance in the market.

6
                                        Sovereign System

2.2 Consumer Challenges
2.2.1 Private Key (or Passphrase) Generation and Management
While critical to the function of public blockchain networks, the generation of private keys
presents a primary barrier to entry for most of the population. The ease of account generation
through email and password and the near frictionless integration of single-sign-on technologies
have become the de facto authentication mode. These methods for managing access to services
are widely viewed as secure and painless to generate and manage.        When initially presented
with the novelty of securing a private key or passphrase, coupled with the warning that this task
is critical and that one should employ the utmost seriousness in management, many entrants
may feel overwhelmed and confused. Without an understanding of the history and intent of
the technology, those new to the space, looking to explore the potential value, will nd this
friction a deterrent and look for more straightforward paths to adoption through custodians.
   Furthermore, many reports state that many who understand the importance of self-custody
to safeguard their private keys or passphrases from loss have made mistakes leading to perma-
nent asset loss. Current studies estimate that as much as 20 percent of the digital asset Bitcoin
(BTC) has been lost forever due to mismanagement or loss of private keys [KH20]. Assuming a
20 percent loss of the current circulating supply, approximately 3,800,000 BTC, this represents
USD 60 billion in lost value at the time of writing this paper. These assets were lost by new
entrants and those experienced in self-custody alike, so we cannot expect the early and Late
Majority, most without technical inclinations, to shoulder the burden of self-custody without
support.

2.2.2 Trust Issues
Blockchains facilitate internet transactions between unknown, untrusted parties through trust-
less mechanisms on shared distributed ledgers.      This technology is secure and achieves the
intended goal. However, the early and Late Majority have dierent trust thresholds than the
Early Adopters. Generally, most people trust governments, institutions, and companies to per-
form the function or service they have been created to serve. If they do not trust the entity,
they at least have trust in a process or system the entity operates within to ensure that they
perform the service to minimum standards.
   Decentralized wallets and applications remove the need for trust but introduce uncertainty
and ambiguity for most people accustomed to knowing who they are dealing with in transac-
tions. The trustless setup and operation of blockchain, which ensures condence in transactions,
ironically leads those unfamiliar with how the technology works to distrust the process. Most
internet users will need more time to dive deep to understand the security features of blockchain
networks. The use of blockchain networks for illicit activities and highlighting these issues over
benecial use cases in the public have led many to view decentralized application use and digital
assets as a space to be wary of or only viable as a speculative investment.
   While some decentralized and centralized options and structures are beginning to emerge,
the need for more consumer protections, guidance on regulations, and taxation for actions
taken with digital assets in decentralized and centralized applications creates confusion.      A

                                                                                                7
                                        Sovereign System

long-documented history of projects launching and not delivering after receiving funding, some
pulling funds and not providing without any notice, creates chaos and drives people away from
blockchain-based applications and services.

    Over the past decade, hundreds of centralized digital asset exchanges and custodians have
failed [Wis22]. In many of these cases, the assets and funds of the users who had credits from
deposits of digital assets had their assets frozen, stolen, or used to settle other company debts,
leaving many without recourse. With each occurrence, there is a call for greater enforcement of
regulations on these entities. Still, with technology moving faster than lawmakers are sometimes
capable of acting, it leaves space for further exploitation of consumers, which, in turn, drives
people away from decentralized technologies.

    The traditional nancial industry, and the products they provide, have many consumer
protections built into their oerings. Consumers expect certain assurances that their deposits
are safe from loss and that there are channels to address and mitigate adverse outcomes in
the event of fraudulent charges. Backstops and recourse are an option when incidents occur.
Public systems must address this directly as it is a signicant practical advantage for incumbent
technologies.

2.2.3 Public Data
Public blockchains have distributed shared ledgers that act as a source of truth for all who
engage with the network. The sharing of publicly available data is one of the most important
features of blockchain.   However, many participants fail to understand their lack of privacy
when transacting with known parties or sharing account information across social platforms.
We will revisit the original intent of blockchain, where entities can have trust in transactions
across the internet without knowing the other party involved in a transaction.       However, as
we have reached the early adopter phase of the technology adoption curve, transactions are no
longer siloed to unknown entities. Individuals and companies that transact on public networks
expose the state and activity of their assets, including historical, present, and future data, to
anyone who wishes to research and track them.

    The majority of public blockchain networks are pseudonymous. Public accounts or addresses
are used instead of the participants' names or identifying information. With wider popularity
and sharing of information across social media, the popularity of non-fungible assets, and
broader acceptance of payments with digital assets, people are openly sharing their account
information with friends, families, businesses, and the wider general public.    As soon as one
entity is aware of the public address of another (in public blockchains that do not have a
privacy component), they can trace the state and activity of the assets as the pseudonymity
of the account is broken. This feature exposes any entity that discloses its ledger account to
potential tracking, manipulation, or theft attempts. No other payment system, whether cash or
electronic, operates in such a public manner. Institutions and individuals alike will not accept
a fully open payment system where each party you trade with instantly has access to your
net worth and transaction history. Public blockchain networks will only achieve mass adoption
with consumers, businesses, and institutions when data protections are in place.

8
                                        Sovereign System

2.3 Institutional Challenges
2.3.1 Institution Focus on Permissioned Networks
Governments, institutions, and businesses are fully aware of the issues caused by open data on
pseudonymous blockchain networks. In a recent survey, a majority of Fortune 500 Chief Infor-
mation Ocers, and the companies they serve, were actively working, building, or designing
solutions that include a blockchain component [Gar22]. However, almost all of these solutions
will not operate on public blockchains. Instead, closed networks such as Hyperledger, Quorum,
or a private instance of a public blockchain such as Ethereum with nodes hosted by the key
stakeholders are custom-built for specic use cases. Companies building public blockchains are
primarily creating at ramps or custodial services as a new revenue source through exchange
and management fees. Without privacy, competitors, and possibly even trade partners, would
exploit information that should otherwise only be known to customers and suppliers and, only
then, disclose what is necessary for each particular action or transaction.     One of the most
signicant issues for institutions is the need for accepted industry standards, both technically
and legally, to operate either on permissioned or public networks.

2.3.2 Permissionless Networks Lack of Structure for Compliance
Governments, institutions, and businesses must operate within clearly dened structures. Struc-
tures for operation usually stem from regulations and mutually agreed-upon standards specic
to each industry or market. Institutions have implemented such measures to avoid pitfalls and
failures made by previous entities. Regulatory reporting requires proper data management to
ensure accuracy in disclosing activities to authorities. Data management also includes strict
controls for access to data and hierarchy rules across organizations, including records of access
to data.
   Another primary requirement for institutions is understanding or knowing those with whom
you trade or serve. The degree to which an entity requires disclosure and diligence depends upon
the type of service administered. Typically known as know-your-customer (KYC) and know-
your-business (KYB), these checks help protect businesses, ensure regulations compliance, and
protect against bad actors. Financial institutions or those involved with the transfer or exchange
of money have additional legal and monitoring requirements, such as monitoring for money
laundering (AML) or suspicious transactions. By their pseudonymous nature, public blockchain
networks do not have business logic built into their platforms to manage data, identity, and
compliance properly.   Unless an available solution exists to address all of these concerns, we
will see institutions only adopt blockchain technology to streamline backend business processes
rather than as a transformative tool to empower all participants.

2.4 Closed Networks
Permissioned networks, where key stakeholders (or validators) control the network nodes and
entrants are provisioned onto the network and managed by stakeholders, are at odds with the
original intent for blockchain. Network decentralization is essential to ensure the proper setup

                                                                                                9
                                         Sovereign System

and execution of trustless mechanisms. Without a fair degree of decentralization, or consensus
distribution, the ledger may be subject to modication.
     If the validators of a closed network are not decentralized and have common interests,
ownership and sovereign control of assets are at risk. Without decentralization, whoever runs
the nodes owns and has positive control over the network, including the assets generated and
maintained on the ledger, as logic can change, and transactions may be submitted on behalf
of a user without consent. Furthermore, in private permissioned networks, node operators and
stakeholders could construct hierarchy views to ledger data, preventing some participants from
some or all transaction views, leading to trust, transparency, and control issues.
     The current trend for industry to opt for permissioned over public networks will lead many of
the Early Majority and most of the Late Majority to interact with blockchain technology solely
through permissioned networks where the node operators (stakeholders) are the custodians
maintaining positive control over all network assets. While the improved processes will help
accelerate the speed and eciency with which entities do business, the ideal of the Early
Adopters of blockchain will not be realized.

10
                                        Sovereign System

Chapter 3
Other Issues and Trends

3.1 Data
Businesses have developed data management practices where records for companies and con-
sumers are repeatedly duplicated and housed in numerous data centers. This practice has left
personal and nancial data at risk for exposure.    In the last decade, the 50 most signicant
reported data breaches have exposed nearly 8 billion user accounts with trillions of records
in the hands of attackers.   These breaches and the subsequent loss of customers, nes, legal
fees, and reputation loss have cost businesses and nancial institutions over USD 5 billion each
year. The millions who have dealt with identity theft ramications are on the other end of these
breaches. The energy expended to protect against and deal with data breaches is immeasurable,
representing untold lost productivity globally.
   Even with the threat of potential attacks and breaches, corporations are designing plat-
forms to capture, store, process, analyze, and utilize even more consumer data.      Companies
view every record stored in their databases as potential energy in new monetization schemes.
Consumers have an abstract knowledge that the data they share with service providers drives
monetization beyond the application interface. Still, the methods and frequency with which
this occurs are unknown to the user. These practices create a trust gap between consumers
and service providers, which instills an underlying distrust, whether conscious or not, in our
internet experience.

3.2 Identity
Furthermore, a trend is emerging toward integrating identity into every action, from nancial
services, travel, telecommunications, e-commerce, social platforms, healthcare, gaming, and
more.   While the authors of this paper agree that identity should be the root of all interac-
tions, the implementation method is of concern. Suppose identity is the key in all interactions
connected to the internet. In that case, the individual, or business, should have a majority, if
not complete control, of their identity. Suppose identity data is left to third parties to manage
in a centralized fashion. In that case, abuses will undoubtedly lead to disenfranchisement and
non-equitable treatment of people groups based on algorithms, prevailing biases, or plans laid

                                                                                              11
                                          Sovereign System

out by decision-makers.

3.3 Privacy
Privacy, or protecting sensitive identifying information, is a fundamental right that all entities
should enjoy. Entities can give up this right by abusing systems or freely sharing information.
However, disclosure and use of personal or corporate data should be up to the owner or creator
of that data and not used or manipulated without consent.        Our current information age is
opening us to a reality where privacy is impossible due to the proliferation of collection and
processing of our PII, data, and physical and online interactions.

3.4 Decentralized Identier Ambiguity
Public, decentralized ledgers, databases, and the transactions on them represent an opportunity
for consumers and businesses to regain trust in their internet activities. These tools can also
empower increased ownership over personal and nancial activities and data.        Self-sovereign
identity has emerged as a potential answer to the identity issue. A signicant body of work
now exists with many proofs-of-concept, working applications, and technical standards set
forth by World Wide Web Consortium (W3C) for Decentralized Identiers [Con22] (DIDs).
However, solutions must include a well-dened structure to ensure data integrity. Sources of
identity claims can range from veried issuers to self-issued. Data linked to these claims can go
from SOC2-compliant storage to not being stored by any entity or initially non-existent. This
ambiguity leads to confusion and misunderstanding over the potential weight of a claim. Unless
a previously agreed-upon path where a verier recognizes and accepts claims from an issuer
exists, veriers will need to expend a great deal of energy to source the validity of a claim. In
addition, the lack of precise data management standards for handling, storage, and access can
lead to further confusion and friction.
     Flexible frameworks for DIDs coupled with pseudonymous blockchains present two issues.
First, when an individual or entity can spin up as many claims from as many sources as they
choose, the weight of all claims is reduced. Second, suppose an individual's public account holds
a DID and data or assets. In that case, the holder of that claim will expose certain identifying
information and the state and movement of their assets or transactions to outside parties. This
exposure leads, once again, to privacy issues on public networks.

12
                                         Sovereign System

Chapter 4
Solution Overview

4.1 Sovereign System
We present a structured asset custody and data management solution situated between self-
sovereign and custodial models.     This framework, with its foundation rooted in the unique
identity of each participant, provides users complete control of their data and assets, protections
against asset loss, account management, and enhanced mechanisms for preserving privacy on
public networks. The following is a high-level overview of the Sovereign System.

4.1.1 Initialization
A structured approach outlines each network function and each entity's specic role within the
network. Each entity must meet particular requirements to interact with the system.

4.1.2 Registration
Regardless of function, each entity that joins the network is considered a Member of the network.
Each Member must act in good faith to support the network and its Members. Each Member
must complete a unique identication process, resulting in a unique identity (uID) on-chain.
This process occurs in a closed channel between a Validator and a potential Member.           The
purpose of the process is to ensure that each Member has only one individual account on the
network. This process ensures network integrity and validates the network as a trust layer over
public blockchains.

4.1.3 Secure communication between Member and Validator
There is end-to-end secure communication between Member and Validator. Namely, no other
entity can engage in or access information, identifying or otherwise, sent between these two
entities.

                                                                                                13
                                        Sovereign System

4.1.4 Verication Checks by the Network Participants
Upon creating uID, the Validator returns the encrypted identity credentials to the Member.
The Member and Validator send zero-knowledge proofs to the Producer that this event was
successful and request the Producer admit a new Member to the network. Before admission,
the Producer reviews and veries claims made by the Validator and Member.

4.1.5 Key Share of Main Account through Personal Security Ques-
      tions
In addition to the proof of uniqueness, the Member also commits to a key share of their Main
Account with participating Organizations to ensure fallback measures are in place to recover
their accounts if they lose access to their private keys.    Key share generation includes some
personal and condential information of the Member. The key share design ensures that even
if all participating Organizations collude to gain access to a Member's accounts, they do not
possess enough key shares to accomplish this action.        Involving organizations prevents any
internal or external adversaries to brute-force/attack to the key shares of the Main Account.

4.1.6 Creation of DID and its Protection through On-Chain
After conrming the matching claims made by the Member, Validator, the Producer, and
the Organizations, the Producer creates and submits a DID object to decentralized storage
containing all the proofs, encrypted identity credentials, encrypted key share information, and
all other general setup items.    Anyone can publicly verify that each process was calculated
correctly. The Producer then submits a transaction on-chain to register this Content IDentier
(CID), a hash of the DID. This certication establishes an ocial record on-chain of the Main
Account as part of the network.

4.1.7 Accumulation of Main Account DID objects through Merkle
      Trees
Main Account DID objects (i.e., the public key of the Main Account) are added to a universal
Merkle Tree (called DID Merkle Tree). Namely, whenever a new Member joins the network,
its public key is added to the DID Merkle Tree, and the new DID Merkle Root is updated
on-chain. This way, all users can be integrated and accumulated in a single DID Merkle Root.

4.1.8 Creating Associated Accounts through Private Membership Proof
Once the DID object of a Main Account has been created, its owner can privately use it for
dierent use cases without disclosing any private information about its identity. This privacy-
preserving feature is accomplished through the creation and use of Associated Accounts. More
concretely, a Member rst creates an Associated Account and proves that it is generated de-
terministically from their Main Account and is also privately linked to the current DID Merkle

14
                                        Sovereign System

Root. In this way, anyone can publicly verify that this new Associated Account is valid and
part of the Sovereign System.

4.1.9 Selective Disclosure through Associated Accounts
A Member can re-hash (obfuscate) the Main Account DID object eld, which contains their
credential attributes and creates proof that this obfuscated value is privately linked to the
current DID Merkle Root. The user can now selectively disclose their credentials' attributes
(either condentially or outright) along with authenticity proofs.

4.2 General Assumptions
   Ã‚Âˆ The underlying cryptographic primitives (e.g., elliptic curves (ed25519, JubJub), hash
     functions (SHA256, Poseidon), ZKSNARKs, ÃŽÂ£-proofs, ElGamal Encryption, Pedersen
     Commitments) are assumed to be secure.

   Ã‚Âˆ The participating parties are supposed to utilize secure random number generators.

   Ã‚Âˆ The Algorand public blockchain used to implement the Sovereign System is assumed to
     be secure.

                                                                                          15
                                             Sovereign System

Chapter 5
Cryptographic Background

5.1 Elliptic Curves
As in Bitcoin, secp256k1 [Res10] will be used. The elliptic curve domain parameters over Fp
associated with a Koblitz curve secp256k1 are specied by the sextuple T   = (p, a, b, G, n, h)
where the nite eld Fp is dened by:

p = FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF
    F F F F F F F E F F F F F C2F
  = 2256 Ã¢ÂˆÂ’ 232 Ã¢ÂˆÂ’ 29 Ã¢ÂˆÂ’ 28 Ã¢ÂˆÂ’ 27 Ã¢ÂˆÂ’ 26 Ã¢ÂˆÂ’ 24 Ã¢ÂˆÂ’ 1
                       2
     The curve E : y       = x3 + ax + b over Fp is dened by:

       a = 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
       b = 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000007

The base point G in compressed form is:

       G =02 79BE667E F 9DCBBAC 55A06295 CE870B07 029BF CDB 2DCE28D9
           59F 2815B 16F 81798

     and in uncompressed form is:

     G =04 79BE667E F 9DCBBAC 55A06295 CE870B07 029BF CDB 2DCE28D9
        59F 2815B 16F 81798 483ADA77 26A3C465 5DA4F BF C 0E1108A8 F D17B448
        A6855419 9C47D08F F B10D4B8

     Finally the order n of G and the cofactor are:

n = F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F F E BAAEDCE6 AF 48A03B
   BF D25E8C D0364141
h = 01

16
                                         Sovereign System

5.2 Hash Functions
A hash function

                                      H : {0, 1}Ã¢ÂˆÂ— Ã¢Â†Â’ {0, 1}k
takes a string of arbitrary length as input and produces a xed-size output k (i.e., hash function
compresses the input).
   On a high level, it has the following properties:

   Ã‚Âˆ Deterministic: The same message always outputs in the same hash.

   Ã‚Âˆ Ecient: It is very fast to compute the hash value for any given message.

   Ã‚Âˆ Non-Correlation of Input and Output (Avalanche eect): A small change in a
      message should change the hash value dramatically such that the new hash value is indis-
      tinguishable from the old hash value (i.e., statistically indistinguishable from random).

   Ã‚Âˆ One-way (Second Preimage Resistance): Given H(x), it is infeasible to nd x except
      by trying all possible messages (except with negligible probability).

   Ã‚Âˆ Collision Resistance (Strong Collision Resistance): No ecient adversary can nd
     two arbitrary messages x and y such that x ÃŒÂ¸= y and H(x) = H(y).

   SHA256 is used in Bitcoin while Keccak (SHA-3) is used in Ethereum.            However, these
functions are extremely expensive inside a SNARK circuit. Therefore, in practice, SNARK
                                            +               +
frindly hash functions such as Poseidon [GKR 21], MIMC [AGR 16], Pedersen hash [ZCa17],
and Sinsemilla [ZCa21] are quite ecient compared to SHA family hash functions. Note that
Sinsemilla is an instance of the Pedersen hash function optimized for table lookups in custom
gates. The security properties of Sinsemilla are similar to Pedersen hashes, however, it is not
designed to be used where a random oracle, PRF, or preimage-resistant hash is required. The
only claimed security property of the hash function is collision-resistance for xed-length inputs.
   In the Sovereign System, Poseidon will be used in ZKSNARK proofs due to its security
and eciency features.     Also, in case of security questions and answers, slow hashes such as
PBKDF2 will be used.

Remark. Whenever needed, output of the has functions can be interpreted as a point on the
underlying curve. How this encoding takes place is an implementation matter.

5.3 Pedersen Commitment
5.3.1 Commitment Schemes
Denition 5.3.1. Let Commit : {0, 1}k ÃƒÂ—{0, 1}Ã¢ÂˆÂ— Ã¢Â†Â’ {0, 1}Ã¢ÂˆÂ— be a deterministic polynomial time
algorithm, where k is a security parameter. A (non-interactive) commitment scheme consists
of two protocols between a sender and a receiver:

                                                                                                17
                                          Sovereign System

Commitment phase:
The sender

                                                         Ã¢ÂˆÂ—
     1. chooses (or is given) a secret message m Ã¢ÂˆÂˆ {0, 1} .

                                          k
     2. chooses a random secret r Ã¢ÂˆÂˆ {0, 1} .

     3. produces a commitment Com = Commit(m, r) by applying some public method (i.e., the
       commitment algorithm Commit) dened by the scheme.

     4. makes Com public.

Reveal phase:
     1. The sender reveals m and r .

                                                                        ?
     2. Given Com, m, r , the receiver can check if indeed Commit(m, r) = Com.

5.3.2 Pedersen Commitment Scheme
Pedersen Commitment uses a public group G of large order q in which the discrete logarithm
is hard, and two random public generators G and P (such that the discrete logarithm is not
known to any party).

Commitment phase:
The sender

                                                         Ã¢ÂˆÂ—
     1. chooses (or is given) a secret message m Ã¢ÂˆÂˆ {0, 1} taken in some public message space
       with at least two elements

     2. chooses a random secret r Ã¢ÂˆÂˆ Zq

     3. produces from that m and r a commitment Com = Commit(m, r) = mG + rP .

     4. makes Com public

Reveal phase:
     1. The sender reveals m and r .

                                                                   ?
     2. Given Com, m, r , the receiver can check if indeed mG + rP = Com.

5.4 Threshold ElGamal Encryption
Suppose we have a threshold ElGamal cryptosystem (t, n) over an Elliptic Curve Ep where
p is a large prime and a secret is shared between n parties Pi s while only if t parties could
reconstruct it.

18
                                             Sovereign System

5.4.1 Setup and Distribution of Private Key Shares Through a Dealer
The following Feldman's (t, n)-threshold VSS scheme for sharing a secret s Ã¢ÂˆÂˆ Zq is dened as
an extension of Shamir's scheme [Sch22].

Distribution
   Ã‚Âˆ G is a generator point of Ep with order q (i.e., q = |G|).

   Ã‚Âˆ The dealer has a public and private key pair (pkd , skd ).

   Ã‚Âˆ Each participant already knows pkd .

   Ã‚Âˆ A dealer chooses a polynomial f (x) = a0 + a1 x + . . . + atÃ¢ÂˆÂ’1 xtÃ¢ÂˆÂ’1 Ã¢ÂˆÂˆ Zq [x] where aj Ã¢ÂˆÂˆR Zq
     with j Ã¢ÂˆÂˆ [0, Ã‚Â· Ã‚Â· Ã‚Â· , t Ã¢ÂˆÂ’ 1].

   Ã‚Âˆ X = s Ã‚Â· G is the public key where s = a0 .

   Ã‚Âˆ The dealer computes and distributes the secret private share si = f (i) to Pi for all
     i Ã¢ÂˆÂˆ [1, Ã‚Â· Ã‚Â· Ã‚Â· , n].

   Ã‚Âˆ The dealer nally broadcasts the commitments Bj = aj Ã‚Â· G for all 0 Ã¢Â‰Â¤ j Ã¢Â‰Â¤ t Ã¢ÂˆÂ’ 1.

   Ã‚Âˆ The dealer broadcasts Signskd (h1 , Ã‚Â· Ã‚Â· Ã‚Â· , hn ) where hi = si G.

Verication of the shares
Upon receipt of share si , each participant Pi veries its validity by evaluating the following
equation:

                                                        tÃ¢ÂˆÂ’1
                                                        X
                                          si Ã‚Â· G =            ij Ã‚Â· Bj .
                                                        j=0

   Note that this equation holds if si = f (i) because

                                          tÃ¢ÂˆÂ’1
                                          X                     tÃ¢ÂˆÂ’1
                                                                X                  tÃ¢ÂˆÂ’1
                                                                                   X
                                                    j                     j
                   si Ã‚Â· G = f (0) Ã‚Â· G =         aj i Ã‚Â· G =            aj i Ã‚Â· G =         ij Ã‚Â· Bj .
                                          j=0                   j=0                j=0

   Therefore, any attempts at cheating by the dealer can be detected by the participants.

Reconstruction
   Ã‚Âˆ The secret s = f (0) is recovered as in Shamir's scheme from t valid shares.

Remark (Reconstruction of the Private Key through Lagrange Interpolation).
                                       tÃ¢ÂˆÂ’1        tÃ¢ÂˆÂ’1
                                       X          Y    j
                                  s=         si           with i ÃŒÂ¸= j.
                                       i=0        j=0
                                                      jÃ¢ÂˆÂ’i

                                                                                                     19
                                              Sovereign System

5.4.2 Setup and Distribution of Private Key Shares without a Dealer
The goal now is to let parties P1 , Ã‚Â· Ã‚Â· Ã‚Â· , Pn jointly generate the random polynomial f (x). This is
basically done by having each party Pi , 1 Ã¢Â‰Â¤ i Ã¢Â‰Â¤ n picking a random polynomial fi (x) Ã¢ÂˆÂˆ Zq [x] of
                                                                                      PtÃ¢ÂˆÂ’1
degree at most t Ã¢ÂˆÂ’ 1 (to achieve (t, n) threshold security), and then dening f (x) =  i=0 fi (x).
Let again G be a generator point of Ep with order q (i.e., q = |G|).

     1. Each party Pi runs an instance of Feldman's VSS scheme by choosing a random tÃ¢ÂˆÂ’1-degree
          polynomial, using si Ã¢ÂˆÂˆ Z as a secret value (as described in Section 5.4.1). Namely, Party
          Pi plays the role of the dealer, and parties P1 , Ã‚Â· Ã‚Â· Ã‚Â· , Pn play the role of the participants.
          Hence, Pi plays a double role, namely as a dealer and as a participant. Let fi (x) Ã¢ÂˆÂˆ Zq [x]
          be a random polynomial of degree t Ã¢ÂˆÂ’ 1 generated by a party Pi where fi (x) = ai0 + ai1 x +
          Ã‚Â· Ã‚Â· Ã‚Â· + aitÃ¢ÂˆÂ’1 xtÃ¢ÂˆÂ’1 .

     2. Each party Pi broadcasts the commitments < Bij = aij Ã‚Â· G : 0 Ã¢Â‰Â¤ j Ã¢Â‰Â¤ t Ã¢ÂˆÂ’ 1 > along with
          si Ã‚Â· G, where aij are the coecients of its private polynomial fi and si = fi (0) = ai0 . Let
          Hi = Bi0 .

     3. For 1 Ã¢Â‰Â¤ i, j     Ã¢Â‰Â¤ n, each party Pi privately shares sijPto party Pj where sij denotes the
                                                                  tÃ¢ÂˆÂ’1
          share of si . Note that sij = fi (j), and since f (x) = i=1 fi (x), it follows that xi = f (i).

     4. Each party Pj veries the shares he received by checking for i = 1, Ã‚Â· Ã‚Â· Ã‚Â· , n :

                                                          tÃ¢ÂˆÂ’1
                                                          X
                                              sij Ã‚Â· G =         j k Ã‚Â· Bik
                                                          k=0

          If a check fails for an index i then Pj broadcasts a complaint against Pi .

     5. Party Pi reveals share sij if it receives a complaint against him by party Pj . If any of the
          revealed shares sij fails to satisfy previous check, then Pi is disqualied. Let us dene
          the set QU AL ÃŒÂ¸= Ã¢ÂˆÂ… as the set of qualied players.

                                                                       P
     6. Each party Pi calculates the overall public key H =                 iÃ¢ÂˆÂˆQU AL Hi .
                                                                                           PtÃ¢ÂˆÂ’1
     7. Each party Pi sums all its received shares sij to obtain its share xi =         j=1 sij of the
                                       P
          overall private key xorg =          s
                                       iÃ¢ÂˆÂˆQU AL i (which is not known   by   anyone).

                                                            P
     8. Each party Pi broadcasts its verication key vki =     iÃ¢ÂˆÂˆQU AL sij Ã‚Â·G = xi Ã‚Â·G and SignskOi (vki )
        where skOi is its signing private key which was certied by a Trusted Certicate Authority.

5.4.3 Threshold ElGamal Encryption
The following encryption algorithm outputs C = EncP (m) where H(= x Ã‚Â· G) is a public key
and M is a message over the given eld.

     1.   r Ã¢Â†Â$ ZÃ¢ÂˆÂ—p

20
                                         Sovereign System

   2.   A=rÃ‚Â·G
   3.   B =M +rÃ‚Â·H
   4. return C = (A, B)

5.4.4 Threshold ElGamal Decryption
Let (A, B) = (rG, M + rH) be a ciphertext where r Ã¢ÂˆÂˆ Zq . The threshold decryption protocol
is follows:

   1. Each party Pi takes A as input and uses its private share xi to produce di = xi Ã‚Â· A along
        with a ÃŽÂ£-proof showing that logG Hi = logA di (using EQ proofs presented in Section 6.5).

   2. Let Q be a set of t parties who produced valid di values. Then, the plaintext M can be
        recovered by computing:

                                        X
                                   BÃ¢ÂˆÂ’         ÃŽÂ»Q,i Ã‚Â· di = B Ã¢ÂˆÂ’ x Ã‚Â· A = M .
                                        iÃ¢ÂˆÂˆQ

5.5 Elliptic Curve Integrated Encryption Scheme (ECIES)
                  k
Let H : G Ã¢Â†Â’ {0, 1} be a hash function that maps the elements of G to bit strings of length k .
The hashed ElGamal encryption algorithm is as follows [GKR04]:

5.5.1 Setup
   1. Generate a random number x Ã¢ÂˆÂˆR Zp and compute x.G.

   2. The public and private key pair is (pk, sk) = (x.G, x).

5.5.2 Encryption
Given the public key pk and a message m:

   1. Generate a random number s Ã¢ÂˆÂˆR Zp and compute R = s Ã‚Â· G.

   2. Compute the shared secret Px where P = (Px , Py ) = s.pk .

   3. Compute kE ||kM = Hash(Px ) where Hash is a hash function like SHA512.

   4. Compute the ciphertext as C = EnckE (m) where Enc is a symmetric encryption scheme
        like AES256.

   5. Compute the tag of the encrypted message d = M ACkM (C) where MAC is a hash-based
        message authentication code like HMAC-SHA256.

   6. Output R||C||d.

                                                                                              21
                                         Sovereign System

5.5.3 Decryption
Given the private key sk and a ciphertext R||C||d:

     1. Derive the shared secret Px where P = (Px , Py ) = xR.

     2. Derive the keys: kE ||kM = Hash(Px )

     3. Use MAC to check the tag and output failed if d ÃŒÂ¸= M ACkM (C).

     4. Decrypt the ciphertext: m = DeckE (C).

Remark. The Sovereign System uses ECIES due to its practical ECC encryption scheme and
strong security property.   The Sovereign System extends ECIES to achieve (2,2) encryption
scheme where two entities public keys' are used simultaneously. The entities individually could
only compute the private shares (but not the whole key) during the protocol executions and
are expected to share them with users privately, so that they can recombine and obtain the
whole key.

5.6 Digital Signatures
5.6.1 Edwards-Curve Digital Signature Algorithm (EdDSA)
EdDSA [JL17] is currently used by Cardano, NANO, Stellar Lumens, WAVES, and Libra, and
will be supported by many more blockchains. Compared to ECDSA's signing and verication
steps, EdDSA is simpler and easier to understand and to implement. Both signature algorithms
have similar security strength for curves with similar key lengths.    The EdDSA algorithm is
slightly faster than ECDSA for the most popular curves like edwards25519 and edwards448.
Unlike ECDSA, it is not possible for EdDSA to recover the signer's public key from the signature
and the message.
     EdDSA is a digital signature system with 11 parameters. The generic EdDSA digital signa-
ture system with its 11 input parameters is not intended to be implemented directly. Choosing
parameters is critical for secure and ecient operation. Instead, you would implement a partic-
ular parameter choice for EdDSA (such as Ed25519 or Ed448). Therefore, a precise explanation
of the generic EdDSA is thus not particularly useful for implementers.      For background and
completeness, a succinct description of the generic EdDSA algorithm is given on RFC8062
[JL17].

       Public Parameters

       Ã‚Âˆ Finite eld Fq over odd prime power q .

       Ã‚Âˆ Elliptic curve E over Fq whose group E(Fq ) of Fq -rational points has order #E(Fq ) =
         2c Ã¢Â„Â“ where Ã¢Â„Â“ is a large prime and 2c is called the cofactor. 1 .

22
                                               Sovereign System

Ã‚Âˆ of base point G Ã¢ÂˆÂˆ E(Fq ) with order Ã¢Â„Â“.

Ã‚Âˆ of hash function H with 2b-bit outputs, where 2bÃ¢ÂˆÂ’1 Ã¢Â‰Â¥ q so that elements of Fq and
  curve points in E(Fq ) can be represented by strings of b bits.

Keys

Ã‚Âˆ Secret key: b-bit random string x (where b = 256).

Ã‚Âˆ H(x)= SHA512(x) = (h0 , . . . , h2bÃ¢ÂˆÂ’1 ).

Ã‚Âˆ Derive integer s = 2bÃ¢ÂˆÂ’2 + 3Ã¢Â‰Â¤iÃ¢Â‰Â¤bÃ¢ÂˆÂ’3 2i hi (s is a multiple of 8).
                           P

         Use HL (x) the rst half of H(x) to generate the public key by setting the rst three bits of the rst octet
           and the last bit of the last octet to zero and setting the second last bit of the last octet to one. Hence, we
           set h0 = h1 = h2 = hbÃ¢ÂˆÂ’1 = 0 and hbÃ¢ÂˆÂ’2 = 1. Determine from this new bit string as an integer s Ã¢ÂˆÂˆ Fq using
           little-endian convention.

Ã‚Âˆ Compute P = s.G.
         The public key is encoded as compressed EC point: the y-coordinate, combined with the lowest bit (the parity)
           of the x-coordinate. For Ed25519 the public key is 32 bytes. For Ed448 the public key is 57 bytes

Ã‚Âˆ Public key: Encoding PÃŒÂƒ of P = (xP , yP ) as yP and one (parity) bit of xP (needs b
     bits).

Ã‚Âˆ Compute P from PÃŒÂƒ : xP = Ã‚Â±
                                             p
                                              (yP2 Ã¢ÂˆÂ’ 1)/(dyP2 + 1).
         The private key is generated from a random number, called seed (which should have similar bit length, like
           the curve order). The seed is rst hashed, then the last few bits, corresponding to the curve cofactor (8 for
           Ed25519 and 4 for X448) are cleared, then the highest bit is cleared and the second highest bit is set. These
           transformations guarantee that the private key will always belong to the same subgroup of EC points on the
           curve and that the private keys will always have similar bit length (to protect from timing-based side-channel
           attacks). For Ed25519 the private key is 32 bytes. For Ed448 the private key is 57 bytes.

HashEdDSA Signing

1. Input: (secret key x, message: M ).

2. Compute (h0 , . . . , h2bÃ¢ÂˆÂ’1 ) =H(x).

                       bÃ¢ÂˆÂ’2                           i
                                        P
3. Derive integer s = 2    +                3Ã¢Â‰Â¤iÃ¢Â‰Â¤bÃ¢ÂˆÂ’3 2 hi (s is a multiple of 8).

4.   HR (x) = hb ||hb+1 || Ã‚Â· Ã‚Â· Ã‚Â· ||h2bÃ¢ÂˆÂ’1

                                                                                                                        23
                                                   Sovereign System

                                                                                2b
     5. Deterministically compute r = SHA512(HR (x)||SHA512(M )) Ã¢ÂˆÂˆ {0, Ã‚Â· Ã‚Â· Ã‚Â· , 2 Ã¢ÂˆÂ’ 1}.

           Ã‚Âˆ This r will be 64-octets long, and we treat it as a little-endian integer modulo q.

     6. Calculate the public key point behind r by multiplying it by the curve generator:
        R = r.G.

     7. Calculate h = SHA512(RÃŒÂƒ||PÃŒÂƒ ||SHA512(M )).

     8. Calculate S = r + hs          mod Ã¢Â„Â“.

     9. Return the signature (RÃŒÂƒ, SÃŒÂƒ), with SÃŒÂƒ the b-bit encoding of S

           Ã‚Âˆ The digital signature is 64 bytes (32 + 32 bytes) for Ed25519 and 114 bytes (57 + 57 bytes) for Ed448 (conrming
              that the signer knows m and x).

     Verication

     1. Signature (RÃŒÂƒ, SÃŒÂƒ), public key PÃŒÂƒ , message M

     2. Parse P from PÃŒÂƒ , R from RÃŒÂƒ, and S from SÃŒÂƒ .

     3. Verify that s lies in the half open interval [0, Ã¢Â„Â“].

     4. Calculate h = SHA512(RÃŒÂƒ||PÃŒÂƒ ||SHA512(M )).

                   3       3      3
     5. Calculate 2 S.G = 2 .R + 2 h.P .

                  Ã¢Â€Â² ?
     6. Check S     = S in E (and reject if parsing fails or equation does not hold).

Edwards Curves: Point Addition for q = 5 mod 8
The following algorithm is taken from [JL17, Section 5.1.4]. For point addition, the following
method is recommended. A point (x, y) is represented in extended homogeneous coordinates
(X, Y , Z, T ), with x = X/Z , y = Y /Z , x Ã¢ÂˆÂ— y = T /Z .
    The neutral point is (0, 1), or equivalently in extended homogeneous coordinates (0, Z, Z, 0)
for any non-zero Z .
    The following formulas for adding two points, (x3, y3) = (x1, y1) + (x2, y2), on twisted
Edwards curves with a = Ã¢ÂˆÂ’1, square a, and non-square d are described in Section 3.1 of
[HWCD08, HD08]. They are complete, i.e., they work for any pair of valid input points.

     Ã‚Âˆ A = (Y1 Ã¢ÂˆÂ’ X1 ) Ã¢ÂˆÂ— (Y2 Ã¢ÂˆÂ’ X2 )

24
                                          Sovereign System

     Ã‚Âˆ B = (Y1 + X1 ) Ã¢ÂˆÂ— (Y2 + X2 )

     Ã‚Âˆ C = T1 Ã¢ÂˆÂ— 2 Ã¢ÂˆÂ— d Ã¢ÂˆÂ— T2

     Ã‚Âˆ D = Z1 Ã¢ÂˆÂ— 2 Ã¢ÂˆÂ— Z2

     Ã‚Âˆ E =BÃ¢ÂˆÂ’A

     Ã‚Âˆ F =DÃ¢ÂˆÂ’C

     Ã‚Âˆ G=D+C

     Ã‚Âˆ H =B+A

     Ã‚Âˆ X3 = E Ã¢ÂˆÂ— F

     Ã‚Âˆ Y3=GÃ¢ÂˆÂ—H

     Ã‚Âˆ T3 = E Ã¢ÂˆÂ— H

     Ã‚Âˆ Z3 = F Ã¢ÂˆÂ— G

Edwards Curves: Doubling
The following algorithm is taken from [JL17, Section 5.1.4].        For point doubling, (x3 , y3 ) =
(x1 , y1 ) + (x1 , y1 ), one could just substitute equal points described in Section 5.6.1 (because of
completeness, such substitution is valid) and observe that four multiplications turn into squares.

     Ã‚Âˆ A = X12

     Ã‚Âˆ B = Y12

     Ã‚Âˆ C = 2 Ã¢ÂˆÂ— Z12

     Ã‚Âˆ H =A+B

     Ã‚Âˆ E = H Ã¢ÂˆÂ’ (X1 + Y1 )2

     Ã‚Âˆ G=AÃ¢ÂˆÂ’B

     Ã‚Âˆ F =C +G

     Ã‚Âˆ X3 = E Ã¢ÂˆÂ— F

     Ã‚Âˆ Y3 = G Ã¢ÂˆÂ— H

                                                                                                   25
                                            Sovereign System

     Ã‚Âˆ T3 = E Ã¢ÂˆÂ— H

     Ã‚Âˆ Z3 = F Ã¢ÂˆÂ— G

Edwards Curves: Modular Inversion mod p = 2448 Ã¢ÂˆÂ’ 2224 Ã¢ÂˆÂ’ 1
For inversion modulo p = 2
                          448
                              Ã¢ÂˆÂ’ 2224 Ã¢ÂˆÂ’ 1 , it is recommended to use the identity xÃ¢ÂˆÂ’1 = xpÃ¢ÂˆÂ’2
mod p. Inverting zero should never happen, as it would require invalid input, which would have
been detected before, or would be a calculation error.

5.6.2 Edwards Curves: Square root for q = 5 mod 8
The following algorithm is taken from [AFH20, Appendix F.2 q = 5 (            mod 8)].

     Parameters: F, a nite eld of characteristic p and order q = pm .

     Ã‚Âˆ Input: x, an element of F.

     Ã‚Âˆ Output: z , an element of F such that z 2 = x, if x is square in F.
                                                        ?

     Constants:

     1.   c1 = sqrt(Ã¢ÂˆÂ’1) Ã¢ÂˆÂˆ F, i.e.,c21 == Ã¢ÂˆÂ’1 in F.

     2.   c2 = (q + 3)/8.               # Integer arithmetic

     Procedure:

     1.   tv1 = xc2
     2.   tv2 = tv1 Ã¢ÂˆÂ— c1
     3.   e = (tv12 ) == x
     4.   z = CM OV (tv2 , tv1 , e)   # If e is False, CM OV returns tv2 , otherwise it returns tv1 .

     5. return z

26
                                          Sovereign System

   To prevent against timing attacks, this operation must run in constant time, without re-
vealing the value of c. Commonly, implementations assume that the selector c is 1 for True or
0 for False. In this case, given a bit string C , the desired selector c can be computed by OR-ing
all bits of C together. The resulting selector will be either 0 if all bits of C are zero, or 1 if at
least one bit of C is 1.

Ed25519
Ed25519 is the underlying curve of the EdDSA signature scheme using SHA512 and Curve25519
[LHT16] where

     Ã‚Âˆ q = 2255 Ã¢ÂˆÂ’ 19 (p of edwards25519 in [LHT16])

     Ã‚Âˆ c: base 2 logarithm of cofactor of edwards25519 [LHT16] (i.e., 3).

     Ã‚Âˆ n = 254

     Ã‚Âˆ E/Fq is the twisted Edwards curve

                                                        121665 2 2
                                      Ã¢ÂˆÂ’x2 + y 2 = 1 Ã¢ÂˆÂ’          xy
                                                        121666
     Ã‚Âˆ d of edwards25519 in [LHT16] (i.e., -121665/121666=3709570593466943934313808
        3508754565189542113879843219016388785533085940283555)
     Ã‚Âˆ a = Ã¢ÂˆÂ’1

     Ã‚Âˆ B = (X(P ), Y (P )) of edwards25519 in [LHT16]
        (i.e., (15112221349535400772501151409588531511454012693041857206046113283
        949847762202,463168356949264781694283940034751631413079938662562256157
        83033603165251855960))
     Ã‚Âˆ Ã¢Â„Â“: the order of edwards25519 in [LHT16] where Ã¢Â„Â“ = 2252 + 277423177773723535358
        51937790883648493.
     Ã‚Âˆ B is the unique point E(Fq ) whose y coordinate is 4/5 and whose x coordinate is
        positive where positive is dened in terms of bit-encoding.

           positive coordinates are even coordinates (least signicant bit is cleared)
           negative coordinates are odd coordinates (least signicant bit is set)
     Ã‚Âˆ H is SHA-512 (SHA Ã¢ÂˆÂ’ 512(dom2(phf lag, context)||x) [Hr11]).

     Ã‚Âˆ b = 256.

     Ã‚Âˆ P H(x) = x (identity function).

                                                                                                  27
                                          Sovereign System

     The curve E(Fq ) is birationally equivalent to the Montgomery curve known as Curve25519.
The equivalence is

                                             uÃ¢ÂˆÂš
                                       x=       Ã¢ÂˆÂ’486664,
                                             v
                                                 uÃ¢ÂˆÂ’1
                                            y=
                                                 u+1

Ed448
Ed448 is the underlying curve of the EdDSA signature scheme using SHA512 and Curve25519
[LHT16] where

      Ã‚Âˆ q = 2448 Ã¢ÂˆÂ’ 2224 Ã¢ÂˆÂ’ 1 (p of edwards448 in [LHT16])

      Ã‚Âˆ c: base 2 logarithm of cofactor of edwards448 [LHT16] (i.e., 2).

      Ã‚Âˆ n = 447

      Ã‚Âˆ d of edwards448 in [LHT16] (i.e., - -39081)

      Ã‚Âˆ a=1

      Ã‚Âˆ B = (X(P ), Y (P )) of edwards448 in [LHT16]
        (i.e., (22458004029592430018760433409989603624678964163256413424612546168
        6950415467406032909029192869357953282578032075146446173674602635247710
        ,298819210078481492676017930443930673437544040154080242095928241372331
        506189835876003536878655418784733982303233503462500531545062832660))
      Ã‚Âˆ Ã¢Â„Â“: the order of edwards448 in [LHT16] where
        Ã¢Â„Â“ = 2446 - 13818066809895115352007386748515426880336692474882178609894547503885.

      Ã‚Âˆ H is SHAKE256(dom4(phf lag, context)||x, 114) where SHAKE256(x, y) is the y rst
        octets of SHAKE256 [FP18] output for input x.

      Ã‚Âˆ b = 456.

      Ã‚Âˆ P H(x) = x (identity function).

     The SHA-3 family consists of four cryptographic hash functions, called SHA3-224, SHA3-
256, SHA3-384, and SHA3-512, and two extendable-output functions (XOFs), called SHAKE128
and SHAKE256. Ed448 uses SHAKE256 as a hash function, even if SHAKE256 is specically
dened not to be a hash function. The rst potentially troublesome property is that shorter
outputs are prexes of longer ones. This is acceptable because output lengths are xed. The

28
                                        Sovereign System

second potentially troublesome property is failing to meet standard hash security notions (es-
pecially with preimages). However, the estimated 256-bit security level against collisions and
preimages is sucient to pair with a 224-bit level elliptic curve [JL17]

                                                                                           29
                                            Sovereign System

5.7 Recommended Curve Sizes [MSS17], [BD18]
     Ã‚Âˆ Pairing Friendly Curves: Except the broken parameters, Tate and Ate pairings pre-
       sented in Table A.3 in [IEE13] can be chosen for the curves G1 , G2 , GT . Apart from BN
        curves, BLS12 and KSS curves are also recommended to be used for eciency reasons
        [MSS17, Section 1], [BD18, Section 2].

     Ã‚Âˆ The current state of-the-art Curve Sizes: According to the most recent paper of
        Menezes and Barbulescu [MSS17, Section 6.3], for the 128 bit security, if BN curve with
        embedding degree 12 is used then the size of G1 should be 383 bits and the size of G2
        should be 4596 bits
                              2.

     Ã‚Âˆ Elliptic curve points: P Ã¢ÂˆÂˆ G1 = E(Fq ), and Q Ã¢ÂˆÂˆ G2 = E(Fqk ).

     Ã‚Âˆ Evaluates e(P , Q) as an element in the multiplicative group Fqk .

     Ã‚Âˆ The order n is a large prime number such that n|#E(Fq ) and gcd(n, p) = 1. The integer
       k is known as the embedding degree of the curve and is the smallest integer k such that
       n|q k Ã¢ÂˆÂ’ 1.

5.7.1 Jacobian coordinates
It is often convenient to represent points (x, y) on E(F) in Jacobian projective coordinates
(X : Y : Z), which are dened as follows:

                                           (x, y) Ã¢Â†Â’ (x : y : 1)
                                     (X : Y : Z) Ã¢Â†Â’ (X/Z 2 , Y /Z 3 )
     Projective coordinates are generally useful to avoid computing inversions, and Jacobian
coordinates give some of the fastest group operations for this curve shape. Moreover, the point
addition law in this representation is independent of the coecients of the curve equation.

5.7.2 Parameters

       Ã‚Âˆ u = Ã¢ÂˆÂ’0xd201000000010000

       Ã‚Âˆ k = 12

       Ã‚Âˆ q = 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241
          eabfffeb153ffffb9feffffffffaaab

     2 The parameters in IEEE Std 1363.3-2013: IEEE Standard for Identity-Based Cryptographic Techniques
using Pairings are outdated and no longer correct. For example, if BN curve with embedding degree 12 was
used then 256 bits for G1 and 3072 for G2 would be used. These sizes are no longer secure.

30
                                         Sovereign System

     Ã‚Âˆ r = 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001

                                         E(Fq ) := y 2 = x3 + 4

                                         Fq2 := Fq [i]/(x2 + 1)
                                     E Ã¢Â€Â² (Fq2 ) := y 2 = x3 + 4(i + 1)

5.7.3 Sizes:
   Ã‚Âˆ private key (32 bytes): Big endian integer.
     The private key is just a scalar that your raise curve points to the power of. The subgroup
                                  255
     order for G1 and G2 is r 2       , so for private keys higher than this the point just wraps
                                                        255
     around. Therefore, useful private keys are < 2         and t into 32 bytes.

   Ã‚Âˆ pubkey (48 bytes): 381 bit ane x coordinate, encoded into 48 big-endian bytes. Since
     we have 3 bits left over in the beginning, the rst bit is set to 1 if and only if y coordinate
     is the lexicographically largest of the two valid y s. The public key ngerprint is the rst
     4 bytes of SHA256(serialize(pubkey)).

   Ã‚Âˆ signature (96 bytes): Two 381 bit integers (ane x coordinate), encoded into two 48
     big-endian byte arrays. Since we have 3 bits left over in the beginning, the rst bit is set
     to 1 if and only if the y coordinate is the lexicographically largest of the two valid y s.
     (The term with the i is compared rst, i.e. 3i + 1 > 2i + 7). The second bit is set to 1 if
     and only if the signature was generated using the prepend method, and should be veried
     using the prepend method.

     The signature is a point on the G2 subgroup, which is dened over a nite eld with
     elements twice as big as the G1 curve (G2 is over Fq 2 rather than Fq . Fq 2 is analogous to
     the complex numbers).

5.8 Ed25519 Clamping and Selection of Scalar to make
    compatible with JubJub
5.8.1 Selection of Scalar in ED25519
In Ed25519 signatures, some bit-twiddling is done on the private key and this process is
called clamping.   See [Cra20] for further details.   Clamping is the action of applying some
deterministic manipulation to some input bytes, typically using bitwise operations. It can be
used for many purposes, but one common use is to force arbitrary values into a particular
integer range by setting or zeroing bits in a particular way.
   First, in the key generation, it derives the public key using the following logic. Ed25519
also requires that you SHA512 the seed and use the rst 32-bytes for the clamp. That step is
done simply to protect against bad seed randomness which is non-uniform.

                                                                                                 31
                                                Sovereign System

1        x || y := sha512 . Sum512 ( seed )
2        x [0] &= 248
3        x [31] &= 127
4        x [31] |= 64
         Next, we calculate scalar = x   mod ord(ed25519) in the standard reference implementation.
    However, if scalar is larger than the order of the subgroup for JubJub (i.e.,
    Ã¢Â„Â“ = 2736030358979909402780800718157159386076813972158567259200215660948447373041),
    then start over with a new random seed to calculate the scalar.

    Clearing the lowest three bits.           In the rst line, we are clearing or zeroing the lowest
    three bits of the rst byte. This works because if we & with 0, it will always be 0 in the output,
    but if we & with 1, it will retain whatever value was already there.

    Remark. Cleaning these bits does something known as clearing the cofactor. A cofactor is
    one of the parameters that make up an elliptic curve. The number of points on the elliptic curve
    can be described as = r Ã¢ÂˆÂ—h where r is the prime order of a subgroup and h is the cofactor. If the
    cofactor is 1, like in many of the standardized curves, we do not need to worry about. However,
    if it is not one, careful consideration needs to be made for its implications in cryptographic
    schemes to avoid a few types of attacks, notably small-subgroup attacks and more nuanced
    malleability attacks that aected Monero.

    Setting the highest bit.        The second line and third line work together to clear the 256th
    bit and set the 255th bit to 1. The second line does the clearing using the same logic as the
    rst and the third uses | to set a specic bit. It works using similar logic to how & works, if
    we | with 0 we retain whatever value was there, and if we | with 1 it will always produce 1, so
    we can set a specic bit.

    Remark. The purpose of this is to ensure that the highest bit is always at a xed position.
    X25519 only deals in x-coordinates and there is a simple & ecient way to implement scalar
    multiplication of x-coordinates known as the Montgomery ladder.           The problem with this is
    that some implementations implement it in variable-time based on the position of the highest
    bit. To avoid implementations having to care about this the creator of the ed25519 (Bernstein)
    decided to make this part of the standard so that if the implementation is variable time in that
    way, it will run in constant time because of this clamping.

    5.8.2 Additional Changes in JubJub Clamping
    JubJub Clamping is currently using Blake function is the reference implementation, However,
    in the Sovereign system, we replace SHA512 with the Blake function.

    32
                                          Sovereign System

Chapter 6
Honest-Verier Zero Knowledge
(ÃŽÂ£-proofs)
See [Sch22] for further details of the protocols presented below.

6.1 Schnorr's Protocol: Proving the knowledge of r such
    that P = rG

     Proof Generation

         eqProofGen(public keys: P , G,
                    random values: r)
    1.   u1 Ã¢Â†Â$ ZÃ¢ÂˆÂ—n

    2.   u2 Ã¢Â†Â$ ZÃ¢ÂˆÂ—n

    3.   A1 = u1 G

    4.   A2 = u2 G

    5.   c1 = hash(A1 , A2 ) and c2 = hash(A2 , A1 ).

    6.   w1 = u1 + c1 r

    7.   w2 = u2 + c2 r

    8. return (A1 , A2 , w1 , w2 )

                                                                    33
                                                 Sovereign System

       Verication

           eqProofVer(proof (A1 , A2 , w1 , w2 ),
                       public values P , G)
      1.   c1 = hash(A1 , A2 ) and c2 = hash(A2 , A1 ).

      2. The proof is valid if the following equalities hold, invalid otherwise:

              Ã‚Âˆ w1 G = A1 + c1 P
              Ã‚Âˆ w2 G = A2 + c2 P

6.2 Proving the equality of messages in dierent Pedersen
    Commitments
Prove in (v, r) in C  = vG + rH is consistent with that in the second part of the ciphertext
(ÃŽÂ±, ÃŽÂ²) = (s Ã‚Â· G, vG + sP ).

       Proof Generation

           eqProofGen(public keys: G, P , H, C, ÃŽÂ² ,
                      random values: v, r, s)
      1.   u1 Ã¢Â†Â$ ZÃ¢ÂˆÂ—n

      2.   u2 Ã¢Â†Â$ ZÃ¢ÂˆÂ—n

      3.   u3 Ã¢Â†Â$ ZÃ¢ÂˆÂ—n

      4.   A1 = u1 G + u2 H

      5.   A2 = u1 G + u3 P

      6.   c = hash(G, H, P , C, ÃŽÂ², A1 , A2 ).

      7.   w1 = u1 + vc

      8.   w2 = u2 + rc

      9.   w3 = u3 + sc

     10. return (A1 , A2 , w1 , w2 , w3 )

34
                                           Sovereign System

     Verication

         eqProofVer(proof (A1 , A2 , w1 , w2 ),
                     public values G, P , H, C, ÃŽÂ² )
    1.   c = hash(G, H, P , C, D, A1 , A2 ).

    2. The proof is valid if the following equalities hold, invalid otherwise:

           Ã‚Âˆ w1 G + w2 H = A1 + cC
           Ã‚Âˆ w1 G + w3 P = A2 + cÃŽÂ²

6.3 Proof of Knowledge in a Pedersen Commitment
The following proof proves knowledge of x, y such that B = xG + yP , for given B .

     Proof Generation

         PedersenProofGen(public keys: G, P , B ,
                    secret values: x, y )
    1.   u1 Ã¢Â†Â$ ZÃ¢ÂˆÂ—n

    2.   u2 Ã¢Â†Â$ ZÃ¢ÂˆÂ—n

    3.   A = u1 G + u2 P

    4.   c = hash(A)

    5.   r = u1 + cx

    6.   s = u2 + cy

    7. return (A, r, s)

     Verication

         PedersenProofVer(proof (A, r, s))
    1.   c = hash(A)

                                                                                     35
                                            Sovereign System

      2. The proof is valid if the following equality holds, invalid otherwise:

             Ã‚Âˆ rG + sP = A + cB

6.4 AND Composition of Schnorr's Protocol
We use Schnorr's protocol with equality composition which is basically an and-composition
with common witness [Sch22].
     Given two relations R1    = {(v1 ; w1 )} and R2 = {(v2 ; w2 )}, a ÃŽÂ£ - protocol is obtained for
relation R1 Ã¢ÂˆÂ§ R2 := {(v1 , v2 ; w1 , w2 ) : (v1 ; w1 ) Ã¢ÂˆÂˆ R1 , (v2 ; w2 ) Ã¢ÂˆÂˆ R2 } by running a ÃŽÂ£-protocol for
R1 and a ÃŽÂ£-protocol for R2 in parallel, using a common challenge (assuming that both protocols
use the same challenge space). Given two public keys h1 and h2 , a proof of knowledge of both
logg h1 and logg h2 is obtained, by running two instances of Schnorr's protocol in parallel, using
a common challenge.

      Proof Generation

           ANDProofGen(public keys: h1 , h2 ,
                      random values: r1 , r2 )
      1.   u1 Ã¢Â†Â$ ZÃ¢ÂˆÂ—n

      2.   u2 Ã¢Â†Â$ ZÃ¢ÂˆÂ—n

      3.   A1 = u1 G

      4.   A2 = u2 G

      5.   c = hash(A1 , A2 )

      6.   w1 = u1 + cr1

      7.   w2 = u2 + cr2

      8. return (A1 , A2 , w1 , w2 )

      Verication

           ANDProofVer(proof (A1 , A2 , w1 , w2 ))

36
                                           Sovereign System

       1.   c = hash(A1 , A2 )

       2. The proof is valid if the following equalities hold, invalid otherwise:

              Ã‚Âˆ w1 G = A1 + ch1
              Ã‚Âˆ w2 G = A2 + ch2

6.5 Equality Composition of Schnorr's Protocol
Let Encpkassociate (m) = (A, B) = (rG, mG + rP ) where pkassociate = P with P = xG. We prove
that

                             {(P , G, A, B, m; r) : A = rG, B Ã¢ÂˆÂ’ mG = rP }.
   Given two public values A and B Ã¢ÂˆÂ’ mG, we prove that both logG A and logP (B Ã¢ÂˆÂ’ mG) is
equal, by running two instances of Schnorr's protocol in parallel, using a common challenge.

       Proof Generation

            EQUALITYProofGen(public values: P , G, A, B, m,
                       random values: r )
       1.   u Ã¢Â†Â$ ZÃ¢ÂˆÂ—n

       2.   A1 = uG

       3.   A2 = uP

       4.   c = hash(A1 , A2 )

       5.   w = u + cr

       6. return (A1 , A2 , w)

       Verication

            ANDProofVer(proof (A1 , A2 , w))
       1.   c = hash(A1 , A2 )

                                                                                           37
                                         Sovereign System

     2. The proof is valid if the following equalities hold, invalid otherwise:

          Ã‚Âˆ wG = A1 + cA
          Ã‚Âˆ wP = A2 + c(B Ã¢ÂˆÂ’ mG)

38
                                             Sovereign System

6.6 Proving the Equality of the Secret Between JubJub
    and ed25519
   Ã‚Âˆ Let |G1 | = p and |G2 | = q where G1 is the ed25519 and G2 is the JubJub curve.

   Ã‚Âˆ Let n be the bit length of q (since q < p).

   Ã‚Âˆ Let G1 , H1 be generators of G1 .

   Ã‚Âˆ Let G2 , H2 be generators of G2 .

   Ã‚Âˆ Let pk = x Ã‚Â· G1 where x = x1 || Ã‚Â· Ã‚Â· Ã‚Â· ||xn with xi Ã¢ÂˆÂˆ {0, 1}. Note that pk is a public key
     which will be used on Algorand.

   Ã‚Âˆ Let Com1,i = xi Ã‚Â· G1 + si Ã‚Â· H1 for some randomness si .

   Ã‚Âˆ Let Com2,i = xi Ã‚Â· G2 + ti Ã‚Â· H2 for some randomness ti .

   Ã‚Âˆ Given public values Com1,i , Com2,i and private values (xi , si , ti ), we want to prove that

      (Com1,i = si Ã‚Â· H1 Ã¢ÂˆÂ§ Com2,i = ti Ã‚Â· H2 ) Ã¢ÂˆÂ¨ (Com1,i = G1 + si Ã‚Â· H1 Ã¢ÂˆÂ§ Com2,i = G2 + ti Ã‚Â· H2 ).

   Namely, if xi = 0 then Com1,i = si Ã‚Â· H1 and Com2,i = ti Ã‚Â· H2 , and if xi = 1 then
Com1,i Ã¢ÂˆÂ’ G1 = si Ã‚Â· H1 and Com2,i Ã¢ÂˆÂ’ G2 = ti Ã‚Â· H2 . Therefore, we will prove that

   (si = logH1 Com1,i Ã¢ÂˆÂ§ti = logH2 Com2,i )Ã¢ÂˆÂ¨(si = logH1 (Com1,i Ã¢ÂˆÂ’G1 )Ã¢ÂˆÂ§ti = logH2 (Com2,i Ã¢ÂˆÂ’G2 )).

6.6.1 orProofGen: OR-composition Between JubJub and ed25519

    Proof Generation

       orProofGen(public: G1 , H1 , G2 , H2 , Com1,i , Com2,i ,
                  private: (xi , si , ti )
    1. If xi = 0

        (a)    c2,i , w2,i , u1,i Ã¢ÂˆÂˆR Zp
        (b)    cÃ¢Â€Â²2,i , w2,i
                        Ã¢Â€Â²
                            , uÃ¢Â€Â²1,i Ã¢ÂˆÂˆR Zq
        (c)    A1,i = u1,i Ã‚Â· H1
        (d)    A2,i = w2,i Ã‚Â· H1 Ã¢ÂˆÂ’ c2,i (Com1,i Ã¢ÂˆÂ’ G1 )
        (e)    AÃ¢Â€Â²1,i = uÃ¢Â€Â²1,i Ã‚Â· H2
        (f )   AÃ¢Â€Â²2,i = w2,i
                        Ã¢Â€Â²
                            Ã‚Â· H2 Ã¢ÂˆÂ’ cÃ¢Â€Â²2,i (Com2,i Ã¢ÂˆÂ’ G2 )

                                                                                                39
                                                        Sovereign System

          (g)     c = SHA256(A1,i , A2,i , AÃ¢Â€Â²1,i , AÃ¢Â€Â²2,i , Com1,i , Com1,i )
          (h)     c1,i = c Ã¢ÂˆÂ’ c2,i
           (i)    cÃ¢Â€Â²1,i = c Ã¢ÂˆÂ’ cÃ¢Â€Â²2,i
           (j)    w1,i = u1,i + c1,i si
                   Ã¢Â€Â²
          (k)     w1,i = uÃ¢Â€Â²1,i + cÃ¢Â€Â²1,i ti

     2. If xi = 1

          (a)     c1,i , w1,i , u2,i Ã¢ÂˆÂˆR Zp
          (b)
                           Ã¢Â€Â²
                  cÃ¢Â€Â²1,i , w1,i , uÃ¢Â€Â²2,i Ã¢ÂˆÂˆR Zq
          (c)     A1,i = w1,i Ã‚Â· H1 Ã¢ÂˆÂ’ c1,i Com1,i
          (d)     A2,i = u2,i Ã‚Â· H1
          (e)
                           Ã¢Â€Â²
                  AÃ¢Â€Â²1,i = w1,i Ã‚Â· H2 Ã¢ÂˆÂ’ cÃ¢Â€Â²1,i Com2,i
           (f )   AÃ¢Â€Â²2,i = uÃ¢Â€Â²2,i Ã‚Â· H2
          (g)     c = SHA256(A1,i , A2,i , AÃ¢Â€Â²1,i , AÃ¢Â€Â²2,i , Com1,i , Com2,i )
          (h)     c2,i = c Ã¢ÂˆÂ’ c1,i
           (i)    cÃ¢Â€Â²2,i = c Ã¢ÂˆÂ’ cÃ¢Â€Â²1,i
           (j)    w2,i = u2,i + c2,i si
                   Ã¢Â€Â²
          (k)     w2,i = uÃ¢Â€Â²2,i + cÃ¢Â€Â²2,i ti
                               Ã¢Â€Â²      Ã¢Â€Â²                    Ã¢Â€Â²      Ã¢Â€Â²                    Ã¢Â€Â²      Ã¢Â€Â²
     3. return (A1,i , A2,i , A1,i , A2,i , c1,i , c2,i , c1,i , c2,i , w1,i , w2,i , w1,i , w2,i )

40
                                                         Sovereign System

       Verication (A1,i , A2,i , AÃ¢Â€Â²1,i , AÃ¢Â€Â²2,i , c1,i , c2,i , cÃ¢Â€Â²1,i , cÃ¢Â€Â²2,i , w1,i , w2,i , w1,i
                                                                                               Ã¢Â€Â²      Ã¢Â€Â²
                                                                                                   , w2,i )

       1.   c = SHA256(A1,i , A2,i , AÃ¢Â€Â²1,i , AÃ¢Â€Â²2,i , Com1,i , Com2,i )

       2. The proof is valid if the following equalities hold, invalid otherwise:

                                ?
               Ã‚Âˆ c1,i + c2,i = c
                                ?
               Ã‚Âˆ cÃ¢Â€Â²1,i + cÃ¢Â€Â²2,i = c
                               ?
               Ã‚Âˆ w1,i Ã‚Â· H1 = A1,i + c1,i Com1,i
                               ?
               Ã‚Âˆ w1,i
                  Ã¢Â€Â²
                      Ã‚Â· H2 = AÃ¢Â€Â²1,i + cÃ¢Â€Â²1,i Com2,i
                               ?
               Ã‚Âˆ w2,i Ã‚Â· H1 = A2,i + c2,i (Com1,i Ã¢ÂˆÂ’ G1 )
                               ?
               Ã‚Âˆ w2,i
                  Ã¢Â€Â²
                      Ã‚Â· H2 = AÃ¢Â€Â²2,i + cÃ¢Â€Â²2,i (Com2,i Ã¢ÂˆÂ’ G2 )

6.6.2 eqProofGen: EQ proof to use in JubJub: Proving the knowl-
      edge of s where s Ã‚Â· H1 = Com1 Ã¢ÂˆÂ’ pk
Once the OR proof in the previous section has been veried, both the prover and verier can
compute:

            Pn iÃ¢ÂˆÂ’1
  1.         1 2
        Com1 =     Ã‚Â· Com1,i = x Ã‚Â· G1 + s Ã‚Â· H1 .
            Pn iÃ¢ÂˆÂ’1
  2. Com2 =  1 2   Ã‚Â· Com2,i = x Ã‚Â· G2 + t Ã‚Â· H2 .

   Next, the prover proves that Com1 = x Ã‚Â· G1 + s Ã‚Â· H1 and pk = x Ã‚Â· G1 indeed correct using
the following equality proof:

                                                                                                              41
                                             Sovereign System

     Proof Generation

          eqProofGen(public keys: Com1 , pk ,
                     random values: s)
     1.   u1 , u2 Ã¢Â†Â$ Zp

     2.   A1 = u1 Ã‚Â· H1

     3.   A2 = u2 Ã‚Â· H1

     4.   c1 = SHA256(Com1 , pk, A1 , A2 ) and c2 = SHA256(A2 , A1 , pk, Com1 ).

     5.   w1 = u1 + c1 s

     6.   w2 = u2 + c2 s

     7. return (Com1 , pk, A1 , A2 , w1 , w2 )

     Verication(Com1 , pk, A1 , A2 , w1 , w2 )

          eqProofVer(public values Com1 , G1 )
     1.   c1 = SHA256(Com1 , pk, A1 , A2 ) and c2 = SHA256(A2 , A1 , pk, Com1 ).

     2. The proof is valid if the following equalities hold, invalid otherwise:

            Ã‚Âˆ w1 Ã‚Â· H1 = A1 + c1 (Com1 Ã¢ÂˆÂ’ pk)
            Ã‚Âˆ w2 Ã‚Â· H1 = A2 + c2 (Com1 Ã¢ÂˆÂ’ pk)

6.6.3 Additional EQ proof to reduce the number of constraints in
      ZKSNARK: Proving the knowledge of t where tÃ‚Â·H2 = Com2 Ã¢ÂˆÂ’pkÃ¢Â€Â²
                           Ã¢Â€Â²
Next, the prover creates pk = x Ã‚Â· G2 . This is added to the protocol to reduce the size of the
                      Ã¢Â€Â²
ZKSNARK circuit. pk will be an additional public input where the number of constraints will
be smaller than giving Com2 as an input. Then, he proves that Com2 = x Ã‚Â· G2 + t Ã‚Â· H2 and
pk Ã¢Â€Â² = x Ã‚Â· G2 indeed correct using the following equality proof:

     Proof Generation

42
                                        Sovereign System

     eqProofGen(public keys: Com2 , pk Ã¢Â€Â² ,
                random values: t)
1.   u1 , u2 Ã¢Â†Â$ Zq

2.   A1 = u1 Ã‚Â· H2

3.   A2 = u2 Ã‚Â· H2

4.   c1 = SHA256(Com2 , pk Ã¢Â€Â² , A1 , A2 ) and c2 = SHA256(A2 , A1 , pk Ã¢Â€Â² , Com2 ).

5.   w1 = u1 + c1 t

6.   w2 = u2 + c2 t
                    Ã¢Â€Â²
7. return (Com2 , pk , A1 , A2 , w1 , w2 )

Verication(Com2 , pkÃ¢Â€Â² , A1 , A2 , w1 , w2 )

     eqProofVer(public values Com2 , G2 )
1.   c1 = SHA256(Com2 , pk Ã¢Â€Â² , A1 , A2 ) and c2 = SHA256(A2 , A1 , pk Ã¢Â€Â² , Com2 ).

2. The proof is valid if the following equalities hold, invalid otherwise:

        Ã‚Âˆ w1 Ã‚Â· H2 = A1 + c1 (Com2 Ã¢ÂˆÂ’ pk Ã¢Â€Â² )
        Ã‚Âˆ w2 Ã‚Â· H2 = A2 + c2 (Com2 Ã¢ÂˆÂ’ pk Ã¢Â€Â² )

                                                                                    43
                                        Sovereign System

Chapter 7
Denitions for the Sovereign System

7.1 Unique identication (uID)
Unique identication, or uID, is a process whereby a user presents biometrics and identity doc-
umentation to conrm they are a unique Member of the network. The uniqueness identication
includes encryption of a Member's data, storage of that data in decentralized storage, creation
of a DID object with claims to said data, a zero-knowledge setup which includes fallback au-
thentication for recovery of data and assets, and an on-chain CID record of the DID object.
Members performing the initial setup of their uID will have a user experience in the application
interface similar to Know-Your-Customer or KYC. Members complete biometric and document
submissions as in the KYC process.    However, data is managed quite dierently in the case
of uID. Before being admitted to the network, a Validator must conform to requirements laid
out by the Producer to comply with the network's specic requirements.       Second, and most
importantly, Validators share no collected data collected for uID with any other entity besides
the Member.     The Member also can request the deletion of all data except for biometrics.
Biometrics information will be stored with the Validator for future uID checks. For the pro-
posed framework based on uniqueness, the Validator must adhere to the specic requirements
presented in 2.2.2.

7.2 Main Account
The Main Account is the hub for all activity in the sovereign system. The Main Account has
two functions. The rst function is producing an on-chain link to the CID of the DID object
created in the uID process.   The second function is to act as the signatory for the Member
during the zero-knowledge setup for all Associated Accounts. The Main Account should hold
no assets and perform no transactions other than the establishment and maintenance of the
DID object connected to the account. With uID linked to the Main Account and all Associated
Accounts created through the Main Account, all accounts are recoverable with uID through the
Main Account.

44
                                        Sovereign System

7.3 Associated Account
The Member creates Associated Accounts for each specic process employed by a Member.
These processes can include holding and sending assets, connecting with peers, connecting to
applications, voting, etc. The Main Account signs a transaction authorizing the creation of the
Associated Account as part of a zero-knowledge setup of the account. This setup is critical to
the recovery methods described in 2.2.2 and allows for the discovery of all Associated Accounts
by the Member without having those connections discoverable to outside parties viewing the
transactions on the network.

7.4 Self Sovereign versus Sovereign versus Custody
In reference to this work, Self Sovereign is the ability to have complete ownership and positive
control over one's data and assets. Self Sovereign implies that the burden for accomplishing this
lies solely with the owner and all actions, including custody, is accepted in full by the owner
with no recourse in the event of an error on the owner's part.
   In the Sovereign System, outside parties can ensure avenues available to protect assets and
data from loss or manipulation and create structures to automate complex processes to reduce
friction. The owner can rely on assistance from outside parties so long as those outside parties
cannot view, access, alter, or transact with the owner's data and assets without the owner's
express consent. Further protections, including recourse for transactions, are possible but not
explored in this work.
   If any outside organization can view, access, alter, or transact an owner's data or assets
without the owner's express consent, the Sovereign model is broken and should be considered
a custodial model.

                                                                                              45
                                             Sovereign System

Chapter 8
Merkle Tree and Authentication Path
The Sovereign System uses Merkle Tree and Authentication path to allow users to generate
Associated Accounts without disclosing the link between the Main Accounts [GJ20, sem22].
                                                                              H              H
   First of all, a complete binary tree T is said to have height H if it has 2  leaves, and 2
-1 interior nodes. By labelling each left child node with a 0 and each right child with 1.
Furthermore, a Merkle hash tree is a complete binary tree equipped with a function hash and
an assignment ÃŽÂ¸ which maps the set of nodes to the set of k -length strings:

                                          x Ã¢Â†Â’ ÃŽÂ¸(x) Ã¢ÂˆÂˆ {0, 1}k .
     For the two child, xlef t and xright of any interior node, xparent , the assignment ÃŽÂ¸ is required
to satisfy

                                    ÃŽÂ¸(xparent ) = hash(xlef t ||xright ).

      Merkle Tree

           MerkleTree(public:       start, maxheight)
      1. Set leaf = start and create empty stack.

      2.   Consolidate: If top 2 nodes on the stack are equal height:
             Ã‚Âˆ Pop node value xright from stack.
             Ã‚Âˆ Pop node value xlef t from stack.
             Ã‚Âˆ Compute xparent = hash(xlef t ||xright ).
             Ã‚Âˆ If height of xparent = maxheight, output xparent and stop.
             Ã‚Âˆ Push xparent onto the stack.

      3.   New Leaf: Otherwise:

46
                                          Sovereign System

          Ã‚Âˆ Compute xlef t = Leaf Calc(leaf ) where Leaf Calc produces ÃŽÂ¸(x) at the cost of
             single computational unit.

          Ã‚Âˆ Push xlef t onto stack.
          Ã‚Âˆ Increment leaf .
          Ã‚Âˆ Loop to step 2.

Authentication Paths.
The goal of Merkle tree traversal is the sequential output of the leaf values, with the associated
authentication data. For each height h < H , we dene Authh to be the value of the sibling of
the height h node on the path from the leaf to the root. The authentication data is then the
set {Authi |0 Ã¢Â‰Â¤ i < H}.
   The correctness of a leaf value may be veried as follows: It is rst hashed together with its
sibling Auth0 , which, in turn, is hashed together with Auth1 , etc., all the way up to the root.
If the calculated root value is equal to the published root value, then the leaf value is accepted
as authentic. Fortunately, when the leaves are naturally ordered from left to right, consecutive
leaves typically share a large portion of the authentication data.

                                      Figure 8.1: Merkle Tree.

                                                                                               47
                                         Sovereign System

Chapter 9
Open Source Crypto Libraries for
ZKSNARKs
The Sovereign System uses ZKSNARKs to ensure that participating parties are doing calcu-
lations correctly without disclosing any information about their private values. This chapter
overviews the details of the implementation of the underlying ZKSNARK proofs.

9.0.1 SNARK friendly curves and hash functions
Remark (SNARK friendly curves). The Algorand network uses the ed25519 curve for signature
generation (in particular, RFC8032 [JL17]). Due to the performance issues, it is very expensive
to utilize RFC8032 in the ZKSNARK computations. Therefore, we need to use SNARK friendly
curves such as JubJub during the proof generation. In order to utilize JubJub in the proofs, we
need to make sure that the private key used in the JubJub curve is the same as in ed25519. The
protocol presented in Section 6.6.1 is used to prove this relation.
Remark (SNARK friendly hash functions). The ZKSNARK proofs are also very expensive
if one uses SHA functions or Blake (as they are used in RFC8032 [JL17]). Therefore, the
architecture of the Sovereign system has been designed in such a way that only SNARK friendly
hash functions such as Poseidon are going to be used.

9.1 Circuit Generation: Circom
     Ã‚Âˆ https://github.com/iden3/circomlib
     Ã‚Âˆ It contains the implementation of dierent cryptographic primitives in Circom language.
     Ã‚Âˆ Circuits are basically statements that we need to prove, and they will be written in this
       language.

9.2 Proof Generation & Verify
     Ã‚Âˆ Rust based compiler: https://github.com/iden3/circom

48
                                       Sovereign System

   Ã‚Âˆ JS based compiler: https://github.com/iden3/snarkjs. This is a JavaScript and
     Pure Web Assembly implementation of ZKSNARK and PLONK schemes. It uses Groth16
     (only 3-point multiplication and 3 pairings) and PLONK.

   Ã‚Âˆ https://github.com/iden3/go-circom-prover-verifier

   Ã‚Âˆ Go implementation: ZKSNARK prover & verier is compatible with Circom. It uses
     bn256 (used by go-ethereum) for the Pairing curve operations.

Remark. The Sovereign system aims to utilize the Plonk construction due to its advantages
such as being trustless, universal, and having an updatable setup.

9.3 Communication: Use gRPC
   Ã‚Âˆ Go: https://grpc.io/docs/languages/go/basics/

   Ã‚Âˆ Node: https://grpc.io/docs/languages/node/quickstart/

9.4 Additional Tutorial & Documentations:
   Ã‚Âˆ ZK Background: https://docs.circom.io/background/background/

   Ã‚Âˆ Circom Language: https://docs.circom.io/circom-language/signals/. For more
     circuits, https://docs.circom.io/more-circuits/more-basic-circuits/.

   Ã‚Âˆ More Documentation: https://iden3-docs.readthedocs.io/en/latest/iden3_repos/
     circom/TUTORIAL.html
   Ã‚Âˆ A tutorial for using Circom: https://hackmd.io/@n2eVNsYdRe6KIM4PhI_2AQ/SJJ8QdxuB

                                                                                      49
                                        Sovereign System

Chapter 10
The Sovereign System

10.1 Entities
10.1.1 Member
A Member is a unique participant in the public network. Members include individuals, busi-
nesses, and institutions (from not-for-prots to government entities).    To avoid issues noted
previously, having a method to ensure uniqueness is critical to providing structure to the pro-
posed Sovereign System. Each Member has a decentralized identier (DID) attributed to their
Main Account that notates their uniqueness on the network. This DID is the Member's anchor
for all web3 data and asset activity.

10.1.2 Issuer
An Issuer is an entity that issues documentation acceptable to a Validator for provision onto
the network or addition to a Member's identity vault.      An Issuer must be approved by the
Producer(s) and any governing Organization(s) before admittance. Formal acceptance of Issuers
and the documentation they produce ensures Members, Veriers, and consumers of DID claims
have condence in the data stored on the network.

10.1.3 Validator
A Validator is an entity that qualies and authenticates documents and data produced by
Issuers, as well as biometric or other identifying data presented to the Validator directly by
the Member to verify uniqueness through a process known as unique identication (uID). The
Validator must be able to employ specic checks against material presented by the Member in-
cluding liveness (proof of being alive, present, and not under duress at time of authentication),
biometric scans, proof that supporting documentation matches biometrics, and most impor-
tantly that a prospective Member does not already have an established main identity account
on the network.

Remark. During the initial implementation, Identity Proxy Server (IPS) will be a trusted
entity between the Validator and the Producer. In the long-term, the functionalities of IPS are

50
                                           Sovereign System

expected to be integrated with the Validator.

10.1.4 Independent parties: Organization1, Ã‚Â· Ã‚Â· Ã‚Â· , Organizationn
An Organization is any network entity that supports and manages the network's operation. In
this paper, we explore an implementation with two Organizations, a Producer and a Foundation.

10.1.5 Producer
A Producer is an Organization responsible for properly operating the network by acting as a
relayer for the network as it receives data from Members and Organizations and approvals from
Validators.   The Producer receives these relays and veries messages through cryptographic
and other calculations, produces DIDs, and leads key management.                The Producer can be
a centralized entity, a centralized entity employing smart contracts for operation, or a fully
decentralized set of smart contracts with key management managed by the contract owner(s)
or the contracts themselves.

10.1.6 Foundation
A Foundation is an Organization responsible for the proper operation of the network by rep-
resenting and advocating for the Members of the network, and auditing the Producer. In this
paper, we envision the representatives of the Foundation are proposed for short-term appoint-
ment to the Foundation by the Producer and the Members of the network who stake dA beyond
their Minimum Commitment vote whether to admit each representative through a majority yes
or no vote. The Members who stake dA beyond their Minimum Commitment also have the
authority to vote a representative out of the Foundation before their term ends. This structure
creates a check and balance system between the Organizations and the Members of the network.

10.1.7 Service Providers
Service Providers leverage uID for authentication, Associated Accounts for creating and man-
aging connections to Members of the network, management of user assets, anonymous or user-
provisioned KYC and ongoing AML, and attribute custom data to the DID to perform user-
owned data operations.

10.2 Trust Assumptions and Requirements
   Ã‚Âˆ Only registered users to the Validator are allowed to use the Sovereign System (for the
     uniqueness of the real users).

   Ã‚Âˆ Let (tpked25519 , tsked25519 ) and (tpkjubjub , tskjubjub ) be the public and private key pairs of
     a user's Main Account on Ed25519 and JubJub curves, respectively. Each user will have
     one single (tpkjubjub , tskjubjub ) (similarly, one single (tpked25519 , tsked25519 )) in the system
     which will be used to create a Main DID object for the user U , called DIDu .

                                                                                                      51
                                            Sovereign System

                          Figure 10.1: A High level Architecture of Sovereign.

          Note that existing systems like Polygon ID do not consider the uniqueness of the
            real users.    In the Sovereign System, there will be only one main identifying DID
            object for one single user assuming that the Validator is honest.

          Also, the user can use the main identifying DID object in other services (such as
            authentication, voting in electronic polls, and privacy preserving complaint trans-
            actions) through selective disclosure by means of only revealing certain information
            of the credentials. The Main Account which resolves to the main identifying DID
            object is not exposed in this process.

     Ã‚Âˆ Each private key of other chains is encrypted with a newly generated public and private
       key pair. This new key is deterministically derived from tskjubjub (which is also equal to
       tsked25519 ).

     Ã‚Âˆ The Sovereign System uses (t, n) threshold secret sharing scheme where at least t shares
       must exist to be able to obtain the private key.        Since the Sovereign System always
       requires user involvement during the key recovery process, the user is supposed to hold
       the controlling interest of the shares of the private key of the Main Account. Therefore,
       even if all participating parties (except the user) are malicious and colluding, they will
       not be able to recover the private key.

     Ã‚Âˆ The user's private key shares of tskjubjub (or tsked25519 ) are generated from selected and
       pre-dened security questions.

52
                                     Sovereign System

     A pool of security questions need to be selected carefully.
     Security answers should be dicult to predict. However, they should be easy to
       remember even years later.
Ã‚Âˆ The security questions are encrypted through (t, n) threshold encryption scheme (between
  n organizations). The selected security questions are not known by any party individually.
  During the registration, they are encrypted through (t, n) encryption scheme. The user
  is expected to encrypt the questions correctly during the registration.

Ã‚Âˆ If users lose everything (all public and private values), they must
     provide their credentials to the Validator and answer to a publicly known pre-dened
       security question correctly to be able to identify the DID object, and

     answer to the additional security questions which were selected by the user (and
       stored in the DID object) during the registration.

Ã‚Âˆ Users can only recover their private keys as long as they remember their answers to the
  selected security questions correctly. Furthermore, their private keys and the private keys
  of other chains cannot be recovered if the security questions are not answered correctly.

Ã‚Âˆ The overall Sovereign System is resistant against threshold number of corruption. Namely,
  the Sovereign System can recover all the keys of users if at least one organization is honest
  or participates in the protocol (in addition to the user).

Ã‚Âˆ The encrypted private keys of other chains are all indistinguishable. Even if DIDu of a
  user is disclosed, no one can learn any information whether the user has protected his/her
  private keys of other chains.

Ã‚Âˆ The Producer cannot obtain any private information about users (i.e., private keys or
  credential attributes).

Ã‚Âˆ Associated Accounts can be proven that they are linked to an existing Main Account
  without disclosing any information about the users or the Main Account.

Ã‚Âˆ The Validator will be a trusted entity. The Validator is assumed to see the credential
  details of the users but is not supposed to share with anyone except sharing the validity
  of the user with the Producer. Note that since Validator sees the identifying information
  during the protocol executions, it can learn which DIDu belongs to which user. However,
  it cannot obtain any information about the activity of the user because Associated Ac-
  counts cannot be linked to any of the Main Accounts. For example, it also cannot learn
  whether the user has created an associated or used in a use case scenario (e.g., encrypting
  a private key, transferring assets, or voting).

  Remark. During the initial implementation, Identity Proxy Server (IPS) will be a trusted
  entity between the Validator and the Producer. The IPS is assumed to see the credential
  details of the users as well as which DIDu belongs to which user, however it is should
  not share with anyone except sharing the validity of the user with the Producer. In this
  case, the Validators cannot learn which DIDu belongs to which user.

                                                                                            53
                                            Sovereign System

10.3 Unique Identication (uID)
As the Sovereign System involves many parties in a cooperative model, a Member must be able
to make authoritative claims to their data and assets. Multiple parties, or Multiple accounts
held by one party, could make claims over an account(s) without authentic claims.                 Adding
unique identity to the network helps build a trust layer over all actions taken on the network.
uID ensures that a Member may only create one Main Account on the network. Not only is
this crucial in helping Members and Organizations transact with greater peace of mind, even
when the counterparties are anonymous or pseudonymous, ensuring uID checks are factual is
also critical to a tamper-proof recovery process for private keys.

10.3.1 Validator Requirements to ensure uID integrity on the network
     Ã‚Âˆ Validators performing services for other entities must run a separate environment to
       specically handle the custom workow of uID to ensure no leakage of personal identifying
       information, or PII, of the registrants and Members. The Producer must have no access
       to identifying information.

     Ã‚Âˆ The Validator must be able to identify previous Registrants and accepted Members while
       processing uID biometrics and documentation and appropriately ag the registration
       attempt to prevent a ctitious or duplicate entry into the network.

     Ã‚Âˆ The Validator must return specic data attributes containing personal identifying infor-
       mation, or PII, we term idcredentials to the Member's device through secure channels
       upon conrmation of uniqueness.

     Ã‚Âˆ The Validator must accept a signature of the compressed idcredentials from the Member.

     Ã‚Âˆ The Validator must agree to verify the signed idcredentials and present this hashed value
       with randomness to the Producer for verication.

     Ã‚Âˆ If there are multiple Validator's, they must agree to share biometric data to ensure en-
       trants to the network are unique.

10.4 Registration and Creation of a Main DID Object
Let G1 , H1 be the base elements of ed25519 (denoted by G1 ) and G2 , H2 be the base elements
of JubJub (denoted by G2 ).

10.4.1 Pre-condition
     Ã‚Âˆ Organizationi has a public and private key pair (pkOi , skOi ) for all i = m, Ã‚Â· Ã‚Â· Ã‚Â· , n.

     Ã‚Âˆ The Identity Proxy Server has (pkips , skips ) and the Producer has (pkp , skp ) public and
       private key pairs.

54
                                         Sovereign System

  Ã‚Âˆ The organizations', the Identity Proxy Server's, and the Producer's public keys pkOi ,
    pkips , and pkp are certied by a trusted Certicate Authority (i.e., signed certicates).
  Ã‚Âˆ The organizations execute a threshold key generation process as described in Section
    5.4.2. At the end of this setup, each Organizationi creates a public and private key pair
    (pubshareorg,i , keyshareorg,i ) with i = m, Ã‚Â· Ã‚Â· Ã‚Â· , n, where pubshareorg,i = keyshareorg,i Ã‚Â· G2 ,
    respectively. If the threshold is Ã¢Â„Â“, then the system will be (Ã¢Â„Â“, n Ã¢ÂˆÂ’ m + 1) threshold security.
    This is required to eliminate the security issues in case of a possible corruption on the
    organization side. These values will not only make the system more robust but also will
    be used to identify the user Main DID object deterministically.

  Ã‚Âˆ Once user opens the Sovereign browser/application, the certicates of all the organizations
    are downloaded and veried immediately.

10.4.2 Registration Flow
 1. The client app will ask the user to select and answer Ã¢Â„Â“ security questions

                           securityquestions = question1 || Ã‚Â· Ã‚Â· Ã‚Â· ||questionÃ¢Â„Â“ .
    Let's denote the answers by

                             securityanswers = answer1 || Ã‚Â· Ã‚Â· Ã‚Â· ||answerÃ¢Â„Â“
    where answeri is the answer to questioni .

    Remark. These answers will be part of the Sovereign Private Key tskjubjub (which is also
    equal to tsked25519 ) as described in the next step. Neither the questions nor the answers
    are supposed to be seen by anyone individually (including the Validator, the Identity Proxy
    Server (IPS), and the Producer). This is necessary to prevent a possible corruption on
    the Validator side (e.g., Ondo) and the Identity Proxy Server (IPS) side, otherwise it
    would be possible to impersonate users.
 2. The user utilizes (t, n) veriable secret sharing scheme (e.g., Feldman's VSS scheme) where
    the user is the dealer and organizations are the members (see [Sch22, Chapter 6.2.1]).
    The Sovereign system always requires user involvement during the key recovery process.
    Therefore, initially the Sovereign system will use (5,7) secret sharing scheme where the
    user holds 3 private key shares while there are also 4 organizations each holding a private
    key share (i.e., m = 4 (organizations), n = 7 (total number of users), t = 5 (the threshold
    level)). To construct such a key management structure, the user

     (a)   i. generates a new and fresh random number seed.

           ii. computes the following:

            1         sk || y := sha512 . Sum512 ( seed )
            2         sk [0] &= 248
            3         sk [31] &= 127
            4         sk [31] |= 64
            5

                                                                                                   55
                                                   Sovereign System

               iii. calculates x = sk       mod ord(ed25519) in the standard reference implementation.
               iv. If x is larger than the order of the subgroup for JubJub (i.e.,
                   Ã¢Â„Â“= 2736030358979909402780800718157159386076813972158567259200215660948447373041),
                   then start over with a new random seed to calculate the scalar (i.e., go to step 1(b)i.)
                   1

         (b) generates a public and private key pair (tpked25519 , tsked25519 ) and (tpkjubjub , tskjubjub )
              such that

                Ã‚Âˆ tsked25519 = tskjubjub = x,
                Ã‚Âˆ tpked25519 = x Ã‚Â· G1 , and
                Ã‚Âˆ tpkjubjub = x Ã‚Â· G2 .
              Note that (tpked25519 , tsked25519 ) and (tpkjubjub , tskjubjub ) are the key pairs belong to
              the main account on the ed25519 and the JubJub curves, respectively.

         (c) encrypts seed through tpkjubjub .
                                                                        256
                i. generates a new random key K Ã¢ÂˆÂˆR {0, 1}                     and computes

                                                      CTseed = AESEncK (seed).

               ii. generates an ephemeral (fully random) key pair: (eprivkeyseed , epubkeyseed ) where

                                                   epubkeyseed = eprivkeyseed Ã‚Â· G2 .

               iii. computes the shared key:

                                             ss = SHA512((eprivkeyseed Ã‚Â· tpkjubjub ).x)

                   where    (eprivkeyseed Ã‚Â· tpkjubjub ).x is the x axis of eprivkeyseed Ã‚Â· tpkjubjub with
                   eprivkeyseed Ã‚Â· tpkjubjub = tskjubjub Ã‚Â· epubkeyseed .
               iv. computes the ciphertext: CTseed,key = AESEncssenc (K) and
                   dseed,key = M ACssmac (CTseed,key ) where ssenc ||ssmac = ss.
         (d) generates a random number saltsecanswers .
                                                             u,1           u,mÃ¢ÂˆÂ’1
         (e) calculates m Ã¢ÂˆÂ’ 1 private key shares (tskjubjub , Ã‚Â· Ã‚Â· Ã‚Â· , tskjubjub ) for himself/herself and
                                   O,m                 O,n
             private key shares tskjubjub , Ã‚Â· Ã‚Â· Ã‚Â· , tskjubjub for organizations as follows:
                                u
                 i calculate tskjubjub,secans = P BKDF 2(saltsecanswers , securityanswers).
                               u,i                  u
                ii generate tskjubjub = P BKDF 2(tskjubjub,secans , i) for i = 1, Ã‚Â· Ã‚Â· Ã‚Â· , m Ã¢ÂˆÂ’ 1.
                                               O,m
               iii generate a random number tskjubjub (to be able to calculate the unique polyno-
                   mial.).

               iv through Lagrange interpolation, calculate the polynomial p(x)                       = a0 + a1 x +
                  a2 x2 + Ã‚Â· Ã‚Â· Ã‚Â· + atÃ¢ÂˆÂ’1 xtÃ¢ÂˆÂ’1 such that
                                                                              u,1                 u,mÃ¢ÂˆÂ’1       O,m
                       (p(0), p(1), Ã‚Â· Ã‚Â· Ã‚Â· , p(m Ã¢ÂˆÂ’ 1), p(m)) = (tskjubjub , tskjubjub , Ã‚Â· Ã‚Â· Ã‚Â· , tskjubjub , tskjubjub ).
     1 We need this step to make sure that the public keys generated on both curves have the same private keys.
See Section 5.8 for the reasoning of the calculations.

56
                                             Sovereign System

                             O,i
              v calculate tskjubjub = p(i) for i = m + 1, Ã‚Â· Ã‚Â· Ã‚Â· , n.

           where PBKDF2 is a password based key derivation function
                                                                                          2.

           Remark. Note that the constant term of the polynomial p(x) is tskjubjub (i.e., a0 =
           tskjubjub ). While computing the shares of the organizations, we need to make sure that
           none of these shares are equal to a0 . Surely, the probability of being equal is negligible,
           however, it's still important to remove this exceptional case in the implementation.
           Namely, if it becomes equal, then we go back to Step 2.b.iii where new fresh random
           numbers for the organizations are regenerated.
           Remark. The user has now a public and the private key pair (tpkjubjub , tskjubjub )
           where the shares of tskjubjub are dened as

                                    u,1                 u,mÃ¢ÂˆÂ’1       O,m                 O,n
                                (tskjubjub , Ã‚Â· Ã‚Â· Ã‚Â· , tskjubjub , tskjubjub , Ã‚Â· Ã‚Â· Ã‚Â· , tskjubjub )

           and tpkjubjub = tskjubjub Ã‚Â· G2 .

       (f ) calculates Bj = aj Ã‚Â· G2 for j = 0, Ã‚Â· Ã‚Â· Ã‚Â· , t Ã¢ÂˆÂ’ 1.

       (g) The user submits (name, surname, tpked25519 ) to the Identity Proxy Server.

   3. The Identity Proxy Server

       (a) creates an ApplicantID (through the Validator).

       (b) generates and stores a random number rips for the user.

       (c) sends the ApplicantID and rips to the user.

   4. The user

       (a) sends the identifying information and the ApplicantID to the Validator.

       (b) informs the Identity Proxy Server about the submission of the identifying informa-
           tion.

   5. The Validator checks if the identifying information is validated through the Validator to
      conrm the uniqueness of the user in the network. The Validator also runs a check to
      ensure the user is both live and present at time of capture and whether the user had
      previously registered.

       (a) If the user fails uID for submission, the Validator must alert the user directly to
           the failure's nature so that the user may attempt to correct the submission error or
           underlying issue.

  2 Instead of PBKDF2, one can also use other slow hashing-functions Scrypt, Bcrypt, and Argon2. Note that
PBKDF2 is commonly implemented as 2048 iterations of hashing to slow down the crackers who have acquired
a list of hashes.

                                                                                                       57
                                               Sovereign System

         (b) If the Validator detects the user is a Member, meaning they have previously com-
              pleted uID successfully, the Validator will prompt the Application to alert the Mem-
              ber to either log into the Application with their Main Account key or begin the
              recovery process.

         (c) The Validator accepts the Registrant's submission if documentation matches their
              biometrics, there are no issues with the Registrants documentation, and they have
              not previously registered with the network through any approved Validator.

         (d) The Validator sends the validation result to the Identity Proxy Server.

     6. The Identity Proxy Server

         (a) checks if the identifying information is validated through the Validator to conrm
              the uniqueness of the user in the network.

         (b) obtains idcredentials from the Validator

         (c) calculates haships = P oseidon(idcredentials, tpked25519 , rips )

         (d) stores haships for the user.

         (e) calculates Signatureips = Signskips (haships ).

          (f ) calculates the encryption of (idcredentials, Signatureips ) using tpked25519 outputting
              Ciphertextips .
         (g) sends Ciphertextips to the user.

     7. The user

         (a) decrypts Ciphertextips and obtains (idcredentials, Signatureips ).

         (b) validates the credential attributes idcredentials (which is displayed as read only),
              and if conrmed, calculates hashuid = P oseidon(idcredentials, tpked25519 , rips ).

         (c) There will be k additional pre-dened and xed security questions for everyone
                                           3 . Let's denote securityquestions
              (initially, k can be set to 1)                                  authrecovery and
              securityanswersauthrecovery for the security questions and their answers, respectively.
              More concretely, the user

                i. veries Signatureips through pkips , rips , tpked25519 , and idcredentials.

               ii. generates ru , su and calculates

                           hashu = ru Ã‚Â· P oseidon(idcredentials, securityanswersauthrecovery )4
                   and

                            hashuprivateshare = su Ã‚Â· P oseidon(saltsecanswers , securityanswers).
     3 Note that these additional security questions will be used in the recovery phase to authenticate users in
addition to the identifying information. If the answer(s) are given correctly then organizations will be convinced
to decrypt the ciphertext of securityquestions. To recover the key, the user not only needs to present the
identifying information but also needs to answer the security questions correctly.
   4 hash may include another private random value like r Ã¢Â€Â²
          u                                                       ips which belongs to the Validator. For each
revocation, a new rips can be used which could make the system anonymous and indistinguishable.

58
                                    Sovereign System

    iii. calculates haships (since rips is already known).

    iv. creates ZKSN ARKuips to prove that hashu , haships , and hashuprivateshare are
        consistent (i.e., the pre-images of these hashes contain idcredentials). More con-
        cretely, given public values hashu , haships , hashuprivateshare , tpkjubjub , tpked25519 ,
        saltsecanswers and private values ru , su , rips , idcredentials, tskjubjub ,
        securityanswersauthrecovery , and securityanswers prove that
         Ã‚Âˆ hashu = ru Ã‚Â· P oseidon(idcredentials, securityanswersauthrecovery )
         Ã‚Âˆ hashuprivateshare = su Ã‚Â· P oseidon(saltsecanswers , securityanswers)
         Ã‚Âˆ haships = P oseidon(idcredentials, tpked25519 , rips ).
         Ã‚Âˆ tpkjubjub = tskjubjub Ã‚Â· G2 .
(d) computes

                                                                   O,i           O,i
               CTprivateshare,i = EncpkOi (Signtsked25519 (hash(tskjubjub )), tskjubjub )
   for i = m, Ã‚Â· Ã‚Â· Ã‚Â· , n where pkOi denotes the public key of Organizationi .

     Ã‚Âˆ Optional:     To detect any possible corruption on the user side, the user can
        provide an additional proof that CTprivateshare,i indeed contains a share being
        part of tskjubjub .

(e) encrypts securityquestions through (k, n) encryption scheme between the organiza-
   tions. Let H(= x Ã‚Â· G2 ) be the overall public key of the organizations (as described
   Section 5.4.2).
                                          256
     i. generates a random key K Ã¢ÂˆÂˆR {0, 1}    and computes

                               CTsq = AESEncK (securityquestions).
     ii. generates an ephemeral (fully random) key pair: (eprivkeysq , epubkeysq ) where

                                      epubkeysq = eprivkeysq Ã‚Â· G2 .
    iii. computes the shared key:

                                   ss = SHA512((eprivkeysq Ã‚Â· H).x)
        where (eprivkeysq Ã‚Â· H).x is the x axis of eprivkeysq Ã‚Â· H with eprivkeysq Ã‚Â· H =
        xorg Ã‚Â· epubkeysq .
    iv. computes the ciphertext: CTsq,key = AESEncssenc (K) and dsq,key = M ACssmac (CTsq,key )
        where ssenc ||ssmac = ss.

(f ) also encrypts the symmetric key K through his/her private key tskjubjub of the main
   account as:

     i. computes his/her shared key:

                               ssu = SHA512((eprivkeysq Ã‚Â· tpkjubjub ).x)
        where (eprivkeysq Ã‚Â·tpkjubjub ).x is the x axis of eprivkeysq Ã‚Â·tpkjubjub with eprivkeysq Ã‚Â·
        tpkjubjub = tskjubjub Ã‚Â· epubkeysq .

                                                                                                59
                                             Sovereign System

             ii. computes the ciphertext: CTkey,user = AESEncssu,E (K)
                and dkey,user = M ACssu,M (CTkey,user ) where ssu,E ||ssu,M = ssu .

        (g) calculates

                CTUsersq = (CTsq , CTsq,key , dkey , CTkey,user , dkey,user , epubkeysq , saltsecanswers ).

        (h) The user computes the proof of relation between JubJub and ed25519 address as
            follows:

                                                     i
              i. computes Commain,1,i = tskjubjub Ã‚Â· G1 + si Ã‚Â· H1 for some randomness si where
                                1                    n              i
                 tskjubjub = tskjubjub || Ã‚Â· Ã‚Â· Ã‚Â· ||tskjubjub with tskjubjub Ã¢ÂˆÂˆ {0, 1}.
                                           i
             ii. computes Commain,2,i = tskjubjub Ã‚Â· G2 + ti Ã‚Â· H2 for some randomness ti .

            iii. creates a proof  orProofGen as orProofGen((G1 , H1 , G2 , H2 , Commain,1,i ,
                 Commain,2,i ), (tskjubjub
                                    i
                                           , si , ti )).
                                           Pn iÃ¢ÂˆÂ’1
             iv. computes Commain,1 =             2 Ã‚Â· Commain,1,i = tskjubjub Ã‚Â· G1 + s Ã‚Â· H1 .
                                           P1n iÃ¢ÂˆÂ’1
              v. computes Commain,2 =          1 2       Ã‚Â· Commain,2,i = tskjubjub Ã‚Â· G2 + t Ã‚Â· H2 .
             vi. creates a proof eqProofGen1 as eqProofGen((Commain,1 , tpked25519 ), s).

            vii. creates a proof eqProofGen2 as eqProofGen((Commain,2 , tpkjubjub ), t).

           viii. sends < Commain,1,i : i = 1, Ã‚Â· Ã‚Â· Ã‚Â· , n >, < Commain,2,i : i = 1, Ã‚Â· Ã‚Â· Ã‚Â· , n >, orProofGen,
                 eqProofGen1, and eqProofGen2 to the Producer.
            Remark. Note that both the prover (the user) and verier (the Producer and the
            organizations) can compute the following:

              Ã‚Âˆ computes Commain,1 = n1 2iÃ¢ÂˆÂ’1 Ã‚Â· Commain,1,i = x Ã‚Â· G1 + s Ã‚Â· H1 .
                                    P

              Ã‚Âˆ computes Commain,2 = n1 2iÃ¢ÂˆÂ’1 Ã‚Â· Commain,2,i = x Ã‚Â· G2 + t Ã‚Â· H2 .
                                    P

        (i) signs as
                                  Signatureuid = Signtsked25519 (hash(userdata))
            where userdata = ( (CTseed , CTseed,key , epubkeyseed ), hashu , hashuid , hips , hashuprivateshare ,
            tpkjubjub , tpked25519 , ZKSN ARKuips , Signatureips , CTUsersq , < Bj : j = 1, Ã‚Â· Ã‚Â· Ã‚Â· , n >
            , < CTprivateshare,i : m, Ã‚Â· Ã‚Â· Ã‚Â· , n >, < Commain,1,i : i = 1, Ã‚Â· Ã‚Â· Ã‚Â· , n >, < Commain,2,i : i =
            1, Ã‚Â· Ã‚Â· Ã‚Â· , n >, orProofGen, eqProofGen1, eqProofGen2).
        (j) sends
                                               Signatureuid , userdata
            to the Producer (the backend of the Sovereign system).

     8. The Producer

        (a) calculates Commain,1 and Commain,2 .

        (b) veries orProofGen, eqProofGen1, and eqProofGen2.

                              ?
        (c) checks if hashuid = haships .

        (d) validates Signatureuid through tpked25519 and hashuid .

60
                                            Sovereign System

     (e) veries   ZKSN ARKuips (which makes sure that the identifying information just
         shared by the user is the same as the one shared by the Identity Proxy Server).

     (f ) forwards (Signatureuid , tpked25519 , hashuid ) to the Identity Proxy Server.

 9. The Identity Proxy Server

                           ?
     (a) checks if hashuid = haships .

    (b) sends Signatureips , haships to the Producer.

10. The Producer

     (a) veries Signatureips through pkips ,

    (b) calculates Signskp (hash(usertotaldatau )) where usertotaldatau = (userdata, Signatureuid ).

     (c) sends (Signskp (hash(usertotaldatau )), usertotaldatau ) to Organizationi Ã¢ÂˆÂ€ i = m, Ã‚Â· Ã‚Â· Ã‚Â· , n.

11. Let's say the set Q = (Organizationj1 , Ã‚Â· Ã‚Â· Ã‚Â· , OrganizationjÃ¢Â„Â“ ) where ji       Ã¢ÂˆÂˆ {1, Ã‚Â· Ã‚Â· Ã‚Â· , n} is
    going to participate in the following calculations. For k = j1 until jÃ¢Â„Â“ , Organizationk

     (a) calculates Commain,1 and Commain,2 .

    (b) veries orProofGen, eqProofGen1, and eqProofGen2.

     (c) veries Signskp (usertotaldatau ) through pkp .

    (d) veries Signatureips through pkips .

     (e) validates Signatureuid through tpked25519 and hashuid .

     (f ) veries ZKSN ARKuips .
                                                                        O,k           O,k
     (g) decrypts CTprivateshare,k and obtains (Signtsked25519 (hash(tskjubjub )), tskjubjub ).

                                        O,k
    (h) veries Signtsked25519 (hash(tskjubjub )) through tpkjubjub .

                      O,k         ? PtÃ¢ÂˆÂ’1 z
     (i) checks if tskjubjub Ã‚Â· G2 =  z=0 k Ã‚Â· Bz to make sure that the calculations have been
         done correctly (see [Sch22, Chapter 6.2.1]).

     (j) computes  hk = keyshareorg,i Ã‚Â· hashu and hÃ¢Â€Â² k = keyshareorg,i Ã‚Â· hashuprivateshare 5
         and creates a Schnorr proof (SchnorrProofOrg1k ) which proves the knowledge of
         keyshareorg,i = logG2 pubshareorg,i = loghashu hk and also creates another Schnorr
         proof (SchnorrProofOrg2k ) keyshareorg,i = logG pubshareorg,i = loghash
                                                        2                       uprivateshare
                                                                                              hÃ¢Â€Â² k .
     (k) computes

         SignatureOk = SignskOk (hk , hÃ¢Â€Â² k , hash(usertotaldatau ), SchnorrProofOrg1k , SchnorrProofOrg2k ).

                                    Ã¢Â€Â²
     (l) sends (SignatureOk , hk , h k , hash(usertotaldatau ), SchnorrProofOrg1k , SchnorrProofOrg2k )
         to the Producer.

5 This is done to have a threshold level of security on a system level.

                                                                                                    61
                                           Sovereign System

 12. The producer

     (a) veries SignatureOk for all k Ã¢ÂˆÂˆ Q.

     (b) veries SchnorrProofOrg1k , SchnorrProofOrg2k for all k Ã¢ÂˆÂˆ Q.
                                                    Ã¢Â€Â²                             Ã¢Â€Â²
                                  P                                               P
     (c) computes hashu,O =   kÃ¢ÂˆÂˆQ ÃŽÂ»Q,k Ã‚Â· hk and hashuprivateshare,O = kÃ¢ÂˆÂˆQ ÃŽÂ»Q,k Ã‚Â· h k where
               P        j
         ÃŽÂ»Q,k = jÃ¢ÂˆÂˆQ k jÃ¢ÂˆÂ’k denote the Lagrange coecients as in the Shamir's scheme.

                                                         Ã¢Â€Â²
     (d) forwards the nal computed value (hashu,O , hashuprivateshare,O ) to the user.

 13. The user

     (a) calculates hashu,selectivedisclosure = P oseidon(idcredentials, tskjubjub ).

     (b) creates a    ZKSN ARKselectivedisclosure proof that hashu,selectivedisclosure is consistent
         with hashuid .    More concretely, given public values hashu,selectivedisclosure , hashuid ,
         tpked25519 , tpkjubjub and private values idcredentials, tskjubjub , rips
            Ã‚Âˆ hashu,selectivedisclosure = P oseidon(idcredentials, tskjubjub )
            Ã‚Âˆ hashuid = P oseidon(idcredentials, tpked25519 , rips ).
            Ã‚Âˆ tpkjubjub = tskjubjub Ã‚Â· G1 .
                                  Ã¢ÂˆÂ’1
     (c) computes identif ieru = ru Ã‚Â· hashu,O and creates a Schnorr proof (SchnorrProof1)
                                        Ã¢ÂˆÂ’1
         which proves the knowledge of ru = loghash    identif ieru .
                                                   u,O

     (d) computes committsku  = sÃ¢ÂˆÂ’1        Ã¢Â€Â²
                                  u Ã‚Â· hashuprivateshare,O and creates another Schnorr proof
                                                          Ã¢ÂˆÂ’1
         (SchnorrProof2) which proves the knowledge of su = loghashÃ¢Â€Â²                 committsku .
                                                                     uprivateshare,O

            Ã‚Âˆ Optional: The user can add an additional proof that he/she indeed uses the
              same ru and su . Note that all these values are already signed by the user but
                still we can add this proof to detect any possible corruption on the user side.

     (e) sends hashu,selectivedisclosure , ZKSN ARKselectivedisclosure , (identif ieru , committsku ,
         SchnorrProof1, SchnorrProof2) to the Producer.

 14. The Producer

     (a) veries ZKSN ARKselectivedisclosure .

     (b) veries SchnorrProof1 and SchnorrProof2.

     (c) calculates Signp,u,selectivedisclosure = Signskp (hashu,selectivedisclosure )

     (d) creates a Sovereign DID object called DIDu which contains

            Ã‚Âˆ Sovereign
            Ã‚Âˆ identif ieru ,
            Ã‚Âˆ tpked25519 ,
            Ã‚Âˆ tpkjubjub ,
            Ã‚Âˆ committsku ,
            Ã‚Âˆ hashu ,

62
                                               Sovereign System

              Ã‚Âˆ haships ,
              Ã‚Âˆ hashuprivateshare ,
              Ã‚Âˆ hashu,selectivedisclosure 6
              Ã‚Âˆ (CTseed , CTseed,key , epubkeyseed ), dseed,key
              Ã‚Âˆ Signskp (hash(usertotaldatau )),
              Ã‚Âˆ Signp,u,selectivedisclosure
              Ã‚Âˆ Signatureuid ,
              Ã‚Âˆ Signatureips ,
              Ã‚Âˆ ZKSN ARKuips ,
              Ã‚Âˆ ZKSN ARKselectivedisclosure ,
              Ã‚Âˆ (hashu,O , hashÃ¢Â€Â²uprivateshare,O )
              Ã‚Âˆ SchnorrProof1, SchnorrProof2,
              Ã‚Âˆ SchnorrProofOrg1k , SchnorrProofOrg2k for all k Ã¢ÂˆÂˆ Q,
              Ã‚Âˆ orProofGen and eqProofGen1 and eqProofGen2,
              Ã‚Âˆ CTUsersq , dct,key
              Ã‚Âˆ < Bj = aj Ã‚Â· G2 : j = 1, Ã‚Â· Ã‚Â· Ã‚Â· , t Ã¢ÂˆÂ’ 1 >,
              Ã‚Âˆ < CTprivateshare,i : i = m, Ã‚Â· Ã‚Â· Ã‚Â· , n >,
              Ã‚Âˆ < SignatureOji , hji , hÃ¢Â€Â² ji : i = 1, Ã‚Â· Ã‚Â· Ã‚Â· , Ã¢Â„Â“ >.
       (e) uploads DIDu to IPFS.

       (f ) calculates CIDu = Hash(DIDu ).

       (g) adds (tpkjubjub , hashu,selectivedisclosure ) to the Merkle tree. Let's say newM erkleRoot
            is the updated Merkle root of the tree (see Chapter 8).

            Remark. Note that the internal calculations can either be stored on Algorand (if it
            is not expensive) or be stored on ochain.
       (h) creates and sends TxIDmerkle which contains newM erkleRoot to Algorand (to update
            the Merkle root of all the DID objects).

        (i) creates and sends TxIDu which contains (identif ieru , tpked25519 , CIDu )

        (j) sends TxIDmerkle , TxIDu back to the user to make ensure that the Sovereign DID
            object has been created successfully.

                                                                                        ?
 15. The user veries if      DIDu has been indeed created and CIDu = Hash(DIDu ), and
      identif ieru , tpked25519 , CIDu ) is stored in the given transaction through TxIDu for tpked25519 .
      The user also checks if his/her tpked25519 and hashu,selectivedisclosure have been added to the
      Merkle tree correctly by obtaining newM erkleRoot from Algorand and checking with
      internal calculations (i.e., the authentication path to the root).

  6 this information will later be masked again to be used to prove selective disclosure in a private manner (i.e.,
it allows users to choose what and how much they share).

                                                                                                                63
                                           Sovereign System

Chapter 11
A Sovereign System Use Case: Encryption
of a Private Key of Other Chains
Members can only have one single Main Account associated with their real identities, while they
may have as many Associated Accounts as they want. Anyone can publicly verify whether a
given Associated Account is valid in the Sovereign System without disclosing the Main Account.
The Associated Accounts are generated from the Main Accounts deterministically (like in BIP32
HD wallets).     More concretely, the Associated Accounts are created through the hash of the
private key of the Main Account (together with some incremented index). This creation process
will help the users to retrieve all their Associated Accounts by only using the Main Account
private key.
     Members can import private keys generated outside the Sovereign System to protect them
against loss by generating Associated Accounts specically to manage the protection of these
keys for retrieval through the Main Account. The method is not network dependent and can
extend to any public or private permissionless or permissioned system. This use case provides
a general layer of asset loss protection across all activity in the market for a Member, removing
one of the heaviest burdens in self-custody, key management. The reduction in physical and
mental costs and increase in ease of use is a crucial innovation initiative to help drive the Early
Majority's intentions towards accepting self-custody as their primary model for the adoption
of blockchain technology.

Assumption 1. The user is assumed to know his/her private key tskjubjub (which is also equal
to tsked25519 ). Therefore, the user can trivially calculate tpked25519 = tskjubjub Ã‚Â· G1 .

11.1 Login to Trustible
The user

     1. enters his/her mnemonic words

     2. calculates tskjubjub

     3. performs the following

64
                                                Sovereign System

       (a) computes identif ieri = P oseidon(tskjubjub , i) where i is an incremented number.

       (b) obtains the (identif ieri , CIDi ) from Algorand through identif ieri

       (c) stops nding until a record (identif ieri , CIDi ) is not found on Algorand.

   4. nds and downloads the corresponding Sovereign DID object DIDu from IPFS through
      CIDi .

11.2 The Protocol for Secure Storage Keys of Other Chains
   1. The user

       (a) logins to Trustible by running the protocol presented in Section 11.1.

       (b) computes skassociated,jubjub,protection,i = P oseidon(tskjubjub , i, random) where random
              is a fresh random number.

       (c) denes seed := skassociated,jubjub,protection,i .

       (d) computes the following:

          1            sk || y := sha512 . Sum512 ( seed )
          2            sk [0] &= 248
          3            sk [31] &= 127
          4            sk [31] |= 64
          5

       (e) calculates xi = sk        mod ord(ed25519) in the standard reference implementation.
        (f ) If xi is larger than the order of the subgroup for JubJub (i.e.,
              Ã¢Â„Â“= 2736030358979909402780800718157159386076813972158567259200215660948447373041),
              then start over with a new random seed to calculate the scalar (i.e., go to step 1e.) 1

       (g) calculates pkassociated,clamped,ed25519,protection,i = xi Ã‚Â· G1 .

       (h) calculates pkassociated,clamped,jubjub,protection,i = xi Ã‚Â· G2 .

        (i) computes pkassociated,jubjub,protection,i = skassociated,jubjub,protection,i Ã‚Â· G2 .

        (j) obtains the most recent newM erkleRoot from Algorand.

       (k) generates a ZKSN ARKassoc,merkle which proves that pkassociated,jubjub,protection,i is linked
              to his/her main account tpkjubjub (=tskjubjub Ã‚Â· G1 ) without disclosing tpkjubjub .
              More concretely, given public values newM erkleRoot, pkassociated,jubjub,protection,i , identif iercoin ,
              and private values i, tskjubjub , tpkjubjub , hashu,selectivedisclosure , random,
              skassociated,jubjub,protection,i , (h1,internal , Ã‚Â· Ã‚Â· Ã‚Â· , hdepthÃ¢ÂˆÂ’1,internal ) 2 .
                procedure ZKSN ARKassoc,merkle ((newM erkleRoot, pkassociated,jubjub,protection,i ), (tskjubjub ,
                pskjubjub , skassociated,jubjub,protection,i , (h1,internal , Ã‚Â· Ã‚Â· Ã‚Â· , hdepthÃ¢ÂˆÂ’1,internal )) :)
                    Check if identif iercoin = P oseidon(tskjubjub , i)

   1 We need this step to make sure that the public keys generated on both curves have the same private keys.
See Section 5.8 for the reasoning of the calculations.
   2 These internal values can be taken from either onchain or ochain depending on the implementation.

                                                                                                              65
                                                 Sovereign System

                   Check if skassociated,jubjub,protection,i = P oseidon(tskjubjub , i, random)
                                                              ?
                   Check if pkassociated,jubjub,protection,i = skassociated,jubjub,protection,i Ã‚Â· G2 .
                                         ?
                   Check if tpkjubjub = tskjubjub Ã‚Â· G2 .
                  h0 Ã¢Â†Â (tpkjubjub , hashu,selectivedisclosure )
                  for i = 1 till depth Ã¢ÂˆÂ’ 1 do
                     hi = hash(hiÃ¢ÂˆÂ’1 ||hi,internal )
                  end for
                              ?
                  Check if hi = newM erkleRoot
               end procedure

     2. The user now

        (a) computes Comassociated,1,i,j = ÃŽÂ±i,j Ã‚Â· G1 + sj Ã‚Â· H1 for some randomness sj where
             xi = ÃŽÂ±i,1 || Ã‚Â· Ã‚Â· Ã‚Â· ||ÃŽÂ±i,n with ÃŽÂ±i,j Ã¢ÂˆÂˆ {0, 1}, j = 1, Ã‚Â· Ã‚Â· Ã‚Â· , n.
        (b) computes Comassociated,2,i,j = ÃŽÂ±i,j Ã‚Â· G2 + tj Ã‚Â· H2 for some randomness tj .

        (c) creates a proof orProofGen as
            orProofGen((G1 , H1 , G2 , H2 , Comassociated,1,i,j , Comassociated,2,i,j ), (ÃŽÂ±i,j , sj , tj )).
                                         Pn jÃ¢ÂˆÂ’1
        (d) computes Comassociated,1,i =     1 2  Ã‚Â· Comassociated,1,i,j = ÃŽÂ±i Ã‚Â· G1 + s Ã‚Â· H1 .
                                         Pn jÃ¢ÂˆÂ’1
        (e) computes Comassociated,2,i =     1 2  Ã‚Â· Comassociated,2,i,j = ÃŽÂ±i Ã‚Â· G2 + t Ã‚Â· H2 .
        (f ) creates a proof eqProofGen1 as
             eqProofGen((Comassociated,1,i , pkassociated,clamped,ed25519,protection,i ), s).
        (g) creates a proof eqProofGen2 as
             eqProofGen((Comassociated,2,i , pkassociated,clamped,jubjub,protection,i ), t).
        (h) computes Signatureregistration = Signskassociated,jubjub,protection,i (data) where
             data = (pkassociated,clamped,jubjub,protection,i ,
             pkassociated,clamped,ed25519,protection,i , pkassociated,jubjub,protection,i , random, identif iercoin ,
             newM erkleRoot, Signatureassociatedaddress , ZKSN ARKassoc,merkle ,
             pkassociated,clamped,ed25519,protection,i , orProofGen, eqProofGen1, eqProofGen2).
         (i) sends Signatureregistration , data to the Producer.

     3. The user

        (a) associated account is displayed with pkassociated,clamped,ed25519,protection,i .

        (b) enters CoinN ame and its private key of the selected network. Let's say skbtc has
             been entered as the private key of his/her Bitcoin address (i.e., CoinN ame = BTC).

       Remark. At this point, skbtc can be veried (e.g., take the hash of the private key and
       verify with the checksum), the corresponding Bitcoin address can be calculated, the current
       balance can be read from the Bitcoin network and displayed on the user screen for further
       validation by the user.

66
                                         Sovereign System

4. The user is now ready to encrypt CoinN ame, skbitcoin , and xi , and provide a proof. Let
  M be be the message to be encrypted where Ã¢Â„Â“ = ||M ||.                  Here below we are using the
  Poseidon based encryption method presented by Khovratovich which [Kho19]. Note that
  the following encryption needs to be performed for CoinN ame, skbitcoin , and xi separately.
  More concretely, the user

                                                    128
   (a) generates a random number r and a nonce N < 2    .

   (b) generates an expanded shared secret key

                       ss = r Ã‚Â· pkassociated,jubjub,protection,i = (ssu [0], ssu [1]) Ã¢ÂˆÂˆ F2q .

    (c) creates a Poseidon input state

                                S = (0, ssu [0], ssu [1], N + Ã¢Â„Â“ Ã¢ÂˆÂ— 2128 ) Ã¢ÂˆÂˆ F4q .

   (d) repeats for 0 Ã¢Â‰Â¤ iÃ¢ÂŒÂˆÃ¢Â„Â“/3Ã¢ÂŒÂ‰

          i. iterate Poseidon on
                                                 S Ã¢Â†Â P oseidon(S)
         ii. absorbs three element of the message (in the last iteration the missing elements
            are set to 0):

                                                S[1] Ã¢Â†Â S[1] + M [3i]
                                             S[2] Ã¢Â†Â S[2] + M [3i + 1]
                                             S[3] Ã¢Â†Â S[3] + M [3i + 2].
        iii. releases three elements of ciphertext:

                                                   CT [3i] Ã¢Â†Â S[1]

                                                 CT [3i + 1] Ã¢Â†Â S[2]
                                                CT [3i + 2] Ã¢Â†Â S[3].
    (e) Iterates Poseidon on S last time:

                                                   S Ã¢Â†Â P (S).

    (f ) Release the last ciphertext element:

                                                 CT .add(S[1]).

   (g) Output (CT1 , CT2 , CT3 ).

   (h) creates a ZKSNARKencryption which proves that (CT1 , CT2 , CT3 ) has been calculated
        correctly (i.e., encrypted with the public key pkassociated,jubjub,protection,i .       More con-
        cretely, given the public values random, pkassociated,jubjub,protection,i , M , and private
        values r, N , show that

                                                                                                      67
                                                Sovereign System

               Ã‚Âˆ ss = r Ã‚Â· pkassociated,jubjub,protection,i = (ssu [0], ssu [1]) Ã¢ÂˆÂˆ F2q .
               Ã‚Âˆ S = (0, ssu [0], ssu [1], N + Ã¢Â„Â“ Ã¢ÂˆÂ— 2128 ) Ã¢ÂˆÂˆ F4q .
               Ã‚Âˆ 0 Ã¢Â‰Â¤ iÃ¢ÂŒÂˆÃ¢Â„Â“/3Ã¢ÂŒÂ‰
                     i. calculate S Ã¢Â†Â P oseidon(S)

                    ii. absorb three element of the message (in the last iteration the missing ele-
                       ments are set to 0):

                                                         S[1] Ã¢Â†Â S[1] + M [3i]
                                                       S[2] Ã¢Â†Â S[2] + M [3i + 1]
                                                      S[3] Ã¢Â†Â S[3] + M [3i + 2].
                    iii. release three elements of ciphertext:

                                                               CT [3i] Ã¢Â†Â S[1]

                                                             CT [3i + 1] Ã¢Â†Â S[2]
                                                             CT [3i + 2] Ã¢Â†Â S[3].
               Ã‚Âˆ iterates Poseidon on S last time: S Ã¢Â†Â P oseidon(S).
               Ã‚Âˆ releases the last ciphertext element: CTj .add(S[1]) for j = 1, 2, 3.
                                   ?
               Ã‚Âˆ checks if CTj = CTjÃ¢Â€Â² for j = 1, 2, 3.
        (i) computes Signaturecoin,userdata = Signskassociated,ed25519,i (pkassociated,jubjub,protection,i , random,
            ((CT1 , CT2 , CT3 ),    Hr , N , Ã¢Â„Â“), ZKSNARKencryption , hash(Signatureregistration )) and
            sends it to the Producer.

     5. The Producer

                                                          Ã¢Â€Â²
        (a) obtains the current Merkle root newM erkleRoot from Algorand.

        (b) veries Signaturecoin,userdata through pkassociated,clamped,ed25519,protection,i .

        (c) veries Signatureregistration through pkassociated,jubjub,protection,i .
                                                               Ã¢Â€Â²
        (d) veries ZKSN ARKassoc,merkle through newM erkleRoot , pkassociated,jubjub,protection,i ,
            random, identif iercoin , and CoinN ame.
        (e) veries orProofGen, eqProofGen1, eqProofGen2.

        (f ) submits the following object DIDcoin to IPFS:

               i. Sovereign
              ii. T rustible

             iii. identif iercoin

             iv. pkassociated,clamped,ed25519,protection,i

              v. pkassociated,clamped,jubjub,protection,i

             vi. (CT1 , CT2 , CT3 )

68
                                          Sovereign System

           vii. (random, Hr , N , Ã¢Â„Â“),
          viii. ZKSN ARKassoc,merkle

           ix. ZKSNARKencryption

      (g) computes CIDcoin = SHA256(DIDcoin ).

      (h) submits a transaction which contains (identif iercoin , CIDcoin ) to the Algorand net-
           work for pkassociated,clamped,ed25519,protection,i . Let T xID be the transaction ID of the
           transaction.
                      Ã¢Â€Â²
       (i) sends T xID to the user to ensure that the encryption has been processed success-
           fully.

                                                                     ?
  6. The user veries if DIDcoin has been indeed created and CIDcoin = Hash(DIDcoin ), and
     (pkassociated,jubjub,protection,i , CIDcoin ) is stored in the given transaction through T xIDu for
     pkassociated,clamped,ed25519,protection,i .

11.3 Recovery of Private Keys of Other Chains
Users can always access the private key of their main account tskjubjub as long as they hold the
identifying information and remember their security answers. We will divide the recovery into
the following two cases:

   Ã‚Âˆ The private key tskjubjub of the main account (which is also equal to tsked25519 )
     is known: In this case, the user can already calculate tpkjubjub and tpked25519 . Users can
     also re-calculate the associated public and private key pairs from tskjubjub as they were
     used to encrypt the private keys of other chains. Therefore, if tskjubjub is known, then
     private keys can be recovered easily.

   Ã‚Âˆ The private key tskjubjub of the main account is unknown: In this case, it is
     assumed that users have no prior knowledge at all (e.g., tskjubjub or even tpkjubjub and
     the main DID object DIDu are all unknown). The goal of this phase is to rst retrieve
     tskjubjub securely after the user is authenticated through the identifying information and
     answering the security questions, and then run the previous step again to recover the keys
     of other chains.

   Let's assume that the user already holds tskjubjub . Next, in order to recover the private key
of the other chains, the user

  1. Repeats i until all identif iercoin s are not found:

      (a) compute identif iercoin = P oseidon(tskjubjub , i) where i is an incremented number.

      (b) obtain the (identif iercoin , CIDcoin ) from Algorand through identif iercoin .

  2. nds and downloads the corresponding Sovereign DID object DIDcoin from IPFS through
     CIDcoin .

                                                                                                     69
                                              Sovereign System

     3. gets (random, Hr , N , Ã¢Â„Â“) from DIDcoin .

     4. computes skassociated,jubjub,protection,i = P oseidon(tskjubjub , i, random).

     5. decrypts the ciphertext (CT1 , CT2 , CT3 ) as follows:

         (a) Generate
                                         ss Ã¢Â†Â k Ã‚Â· pkassociated,jubjub,protection,i .
         (b) Create a Poseidon input state

                                      S = (0, ssu [0], ssu [1], N + Ã¢Â„Â“ Ã¢ÂˆÂ— 2128 ) Ã¢ÂˆÂˆ F4q .

         (c) Repeat for 0 Ã¢Â‰Â¤ iÃ¢ÂŒÂˆÃ¢Â„Â“/3Ã¢ÂŒÂ‰

                i. Iterate Poseidon on S :
                                                     S Ã¢Â†Â P oseidon(S).
               ii. Release three elements of message for j = 1, 2, 3:

                                                  M [3i] Ã¢Â†Â S[1] + CTj [3i]

                                             M [3i + 1] Ã¢Â†Â S[2] + CTj [3i + 1]
                                             M [3i + 2] Ã¢Â†Â S[3] + CTj [3i + 2].
              iii. Modify state:
                                                       S[1] Ã¢Â†Â CTj [3i]
                                                     S[2] Ã¢Â†Â CTj [3i + 1]
                                                    S[3] Ã¢Â†Â CTj [3i + 2].
              iv. If 3 does not divide Ã¢Â„Â“ then check that the last 3 Ã¢ÂˆÂ’ (Ã¢Â„Â“          mod 3) elements of M are
                  0. If not, reject the ciphertext.

         (d) Iterate Poseidon on S last time:

                                                  S Ã¢Â†Â P oseidon(S).

         (e) Check last ciphertext element:

                                                    CTj .last = S[1].

         (f ) Output skCoinN ame := M .

70
                                               Sovereign System

Chapter 12
Full Recovery of Main Accounts
In this section, we will assume that users do not hold the private keys of their main accounts.

12.1         tsk is unknown
   1. The user

        (a) selects the recovery option that does not require the public or private key of the
             main account.

       (b)     i. generates a new and fresh random number seed.

              ii. computes the following:

                1                sk || y := sha512 . Sum512 ( seed )
                2                sk [0] &= 248
                3                sk [31] &= 127
                4                sk [31] |= 64
                5

             iii. calculates x = sk     mod ord(ed25519) in the standard reference implementation.
             iv. If x is larger than the order of the subgroup for JubJub (i.e.,
                    Ã¢Â„Â“= 2736030358979909402780800718157159386076813972158567259200215660948447373041),
                    then start over with a new random seed to calculate the scalar (i.e., go to step 1(b)i.)
                    1

        (c) generates ephemeral public and private key pairs (epubkeyrecover,ed25519 , eprivkeyrecover,ed25519 )
             and (epubkeyrecover,jubjub , eprivkeyrecover,jubjub ) such that

               Ã‚Âˆ eprivkeyrecover,ed25519 = eprivkeyrecover,jubjub = x,
               Ã‚Âˆ epubkeyrecover,ed25519 = x Ã‚Â· G1 , and
               Ã‚Âˆ epubkeyrecover,jubjub = x Ã‚Â· G2 .
             Note that (epubkeyrecover,ed25519 , eprivkeyrecover,ed25519 ) and
             (epubkeyrecover,jubjub , eprivkeyrecover,jubjub ) are ephemeral key pairs which will be used
             to recover the private key of the main account.

   1 We need this step to make sure that the public keys generated on both curves have the same private keys.
See Section 5.8 for the reasoning of the calculations.

                                                                                                          71
                                            Sovereign System

        (d) The user computes the proof of relation between JubJub and ed25519 addresses as
            follows:

                                                     i
              i. computes Commain,1,i = eprivkeyrecover,jubjub Ã‚Â· G1 + si Ã‚Â· H1 for some randomness
                                                            1                                n
                 si where eprivkeyrecover,jubjub = eprivkeyrecover,jubjub || Ã‚Â· Ã‚Â· Ã‚Â· ||eprivkeyrecover,jubjub
                              i
                 with eprivkeyrecover,jubjub Ã¢ÂˆÂˆ {0, 1}.
                                                 i
              ii. computes Commain,2,i = eprivkeyrecover,jubjub Ã‚Â· G2 + ti Ã‚Â· H2 for some randomness
                   ti .
             iii. creates a proof orProofGenRecover as orProofGenRecover((G1 , H1 , G2 , H2 ,
                  Commain,1,i , Commain,2,i ), (eprivkeyrecover,jubjub
                                                        i
                                                                       , si , ti )).
                                          Pn iÃ¢ÂˆÂ’1
             iv. computes Commain,1 =          2 Ã‚Â· Commain,1,i = eprivkeyrecover,jubjub Ã‚Â· G1 + s Ã‚Â· H1 .
                                          P1n iÃ¢ÂˆÂ’1
              v. computes Commain,2 =        1 2  Ã‚Â· Commain,2,i = eprivkeyrecover,jubjub Ã‚Â· G2 + t Ã‚Â· H2 .
             vi. creates a proof
                   eqProofGenRecover1 as eqProofGenRecover((Commain,1 , epubkeyrecover,ed25519 ),
                   s).
            vii. creates a proof
                   eqProofGenRecover2 as eqProofGenRecover((Commain,2 , epubkeyrecover,jubjub ), t).
            Remark. Note that both the prover (the user) and verier (the Producer and the
            organizations) can compute the following:

              Ã‚Âˆ computes Commain,1 = n1 2iÃ¢ÂˆÂ’1 Ã‚Â· Commain,1,i = x Ã‚Â· G1 + s Ã‚Â· H1 .
                                    P

              Ã‚Âˆ computes Commain,2 = n1 2iÃ¢ÂˆÂ’1 Ã‚Â· Commain,2,i = x Ã‚Â· G2 + t Ã‚Â· H2 .
                                    P

        (e) submits (name, surname, epubkeyrecover,ed25519 ) to the Identity Proxy Server.

     2. The Identity Proxy Server

        (a) calculates Commain,1 and Commain,2 .

        (b) validates Signatureuid through epubkeyrecover,ed25519 and hashuid .

        (c) creates an ApplicantID (through the Validator).

        (d) generates and stores a random number rips for the user.

        (e) sends the ApplicantID and rips to the user.

     3. The user

        (a) sends the identifying information (which includes the same credentials used during
            the registration) and the ApplicantID to the Validator.

        (b) informs the Identity Proxy Server about the submission of the identifying informa-
            tion.

     4. The Validator veries the identifying information and conrms the uniqueness of the user
       in the network, and if so, sends the validation result to the Identity Proxy Server.

     5. The Identity Proxy Server

72
                                        Sovereign System

   (a) checks if the identifying information is validated through the Validator to conrm
       the uniqueness of the user in the network.

   (b) obtains idcredentials from the Validator.

   (c) calculates

                     haships = P oseidon(idcredentials, epubkeyrecover,ed25519 , rips ).

       where idcredentials is exactly the one that was used during the registration.

   (d) stores haships for the user.

   (e) calculates
                                    Signatureips = Signskips (haships )
   (f ) calculates the encryption of (idcredentials, Signatureips ) using epubkeyrecover,ed25519
       outputting Ciphertextips .

   (g) sends Ciphertextips to the user.

6. The user

   (a) decrypts Ciphertextips using eprivkeyrecover,ed25519 and obtains (idcredentials, Signatureips ).

   (b) validates the credential attributes idcredentials (which is displayed as read only).

   (c) veries Signatureips through pkips , rips , epubkeyrecover,ed25519 .

   (d) answers securityquestionsauthrecovery as securityanswersauthrecovery .

   (e) generates a fresh and random ru and calculates

                   hashu = ru Ã‚Â· P oseidon(idcredentials, securityanswersauthrecovery )

   (f ) calculates the hash value haships = P oseidon(idcredentials, epubkeyrecover,ed25519 , rips )
       (since rips is already known).

   (g) creates    ZKSN ARKuips,recover such that hashu , haships are consistent (i.e., both
       hashes contain the same input idcredentials).         More concretely, Given public val-
       ues hashu , haships , epubkeyrecover,jubjub , rips and private values ru , idcredentials,
       eprivkeyrecover,jubjub , and securityanswersauthrecovery , prove that
         Ã‚Âˆ hashu = ru Ã‚Â· P oseidon(idcredentials, securityanswersauthrecovery )
         Ã‚Âˆ haships = P oseidon(idcredentials, epubkeyrecover,ed25519 , rips ).
         Ã‚Âˆ epubkeyrecover,jubjub = eprivkeyrecover,jubjub Ã‚Â· G2 .
   (h) signs as
                        Signatureu = Signeprivkeyrecover,ed25519 (hash(userdata))
       where userdata = (ZKSN ARKuips,recover , hashu , haships , epubkeyrecover,jubjub ,
       epubkeyrecover,ed25519 , Signatureips , < Commain,1,i : i = 1, Ã‚Â· Ã‚Â· Ã‚Â· , n >, < Commain,2,i :
       i = 1, Ã‚Â· Ã‚Â· Ã‚Â· , n >, orProofGenRecover, eqProofGenRecover1, eqProofGenRecover2).

                                                                                                73
                                             Sovereign System

         (i) sends
                                               (userdata, Signatureu )
             to the Producer.

     7. The Producer

        (a) veries Signatureu through epubkeyrecover,ed25519 ,

        (b) veries Signatureips through pkips ,

         (c) veries ZKSN ARKuips,recover (which makes sure that the shared credential data by
             the user is the same as the one by the Identity Proxy Server).

        (d) calculates Commain,1 and Commain,2 .

         (e) veries orProofGenRecover, eqProofGenRecover1, and eqProofGenRecover2.

         (f ) calculates usertotaldatau = (userdata, Signatureu ),

        (g) calculates Signp (hash(usertotaldatau )), and

        (h) sends Signp (hash(usertotaldatau )), usertotaldatau to Organizationi Ã¢ÂˆÂ€ i = m, Ã‚Â· Ã‚Â· Ã‚Â· , n.

     8. Let's say the set Q = (Organizationj1 , Ã‚Â· Ã‚Â· Ã‚Â· , OrganizationjÃ¢Â„Â“ ) where ji         Ã¢ÂˆÂˆ {1, Ã‚Â· Ã‚Â· Ã‚Â· , n} is
       going to participate in the following calculations. For k = j1 until jÃ¢Â„Â“ , Organizationk

        (a) veries Signp (usertotaldatau ) through pkp .

        (b) veries Signatureu through epubkeyrecover,jubjub .

         (c) veries Signatureips through pkips .

        (d) calculates Commain,1 and Commain,2 .

         (e) veries orProofGenRecover, eqProofGenRecover1, and eqProofGenRecover2.

         (f ) veries ZKSN ARKuips,recover .

        (g) computes hk = keyshareorg,i Ã‚Â·hashu and creates a Schnorr proof (SchnorrProofOrg1k )
             which proves the knowledge of keyshareorg,i = logG           pubshareorg,i = loghashu hk .
                                                                      2

        (h) computes

                     SignatureOk = SignskOk (hk , hash(usertotaldatau ), SchnorrProofOrg1k ).

         (i) sends (SignatureOk , hk , hash(usertotaldatau ), SchnorrProofOrg1k ) to the Producer.

     9. The producer

        (a) veries SignatureOk for all k = j1 , Ã‚Â· Ã‚Â· Ã‚Â· , jÃ¢Â„Â“ .

        (b) veries SchnorrProofOrg1k for all k = j1 , Ã‚Â· Ã‚Â· Ã‚Â· , jÃ¢Â„Â“ .
                                     P                                P          j
         (c) computes hashu,O =         kÃ¢ÂˆÂˆQ ÃŽÂ»Q,k Ã‚Â· hk where ÃŽÂ»Q,k =        jÃ¢ÂˆÂˆQ k jÃ¢ÂˆÂ’k denote the Lagrange
             coecients as in the Shamir's scheme.

74
                                          Sovereign System

     (d) forwards the nal computed value hashu,O to the user.

10. The user

                                  Ã¢ÂˆÂ’1
     (a) computes identif ieru = ru Ã‚Â·hashu,O and creates a Schnorr proof (SchnorrProofRecover1)
                                        Ã¢ÂˆÂ’1
         which proves the knowledge of ru = loghash     identif ieru .
                                                    u,O

     (b) obtains CIDu from the Algorand network through identif ieru .

     (c) obtains DIDu from the IPFS through CIDu .

     (d) sends identif ieru and SchnorrProofRecover1 to the Producer.

11. The Producer sends the nal value identif ieru , SchnorrProofRecover1 as well as SignatureOi ,
    hi , SchnorrProofOrg1k Ã¢ÂˆÂ€i Ã¢ÂˆÂˆ Q to the organizations to decrypt the security questions.

12. The organizations are now ready to verify the calculations, and if successfully passed,
    calculate their partial private keys and share with the user so that the user can learn the
    security questions.      Let's say the set Q = (Organizationj1 , Ã‚Â· Ã‚Â· Ã‚Â· , OrganizationjÃ¢Â„Â“ ) where
    ji Ã¢ÂˆÂˆ {1, Ã‚Â· Ã‚Â· Ã‚Â· , n} is going to participate in the following calculations. For k = j1 until jÃ¢Â„Â“ ,
    Organizationk

     (a) veries SignatureOk for all k = j1 , Ã‚Â· Ã‚Â· Ã‚Â· , jÃ¢Â„Â“ .

     (b) veries SchnorrProofOrg1k for all k = j1 , Ã‚Â· Ã‚Â· Ã‚Â· , jÃ¢Â„Â“ .

     (c) veries SchnorrProofRecover1.

     (d) obtains CIDu from the Algorand network through identif ieru .

     (e) obtains DIDu from the IPFS through CIDu .

     (f ) obtains epubkeysq , CTsq , and saltsecanswers from the DIDu .

     (g) calculates the shared key as

                                      ssorg,i = keyshareorg,i Ã‚Â· epubkeysq

         with keyshareorg,i Ã‚Â· epubkeysq = eprivkeysq Ã‚Â· pubshareorg,i .

     (h) calculates CTk = Encepubkeyrecover,jubjub (ssorg,i ).

     (i) sends CTk to the Producer.

13. The Producer forwards < CTk : k = j1 , Ã‚Â· Ã‚Â· Ã‚Â· , jÃ¢Â„Â“ > to the user.

14. The user

     (a) decrypts CTk using eprivkeyrecover,jubjub and obtains ssorg,k .

     (b) applies the threshold decryption process (as described in Section 5.4.4) by recom-
         bining the partial decryptions (ssm , Ã‚Â· Ã‚Â· Ã‚Â· , ssn ) as sspreimage .

     (c) calculates ss = SHA512(sspreimage .x) where sspreimage .x is the x coordinate of sspreimage .

     (d) obtains ssenc and ssmac where ss = ssenc ||ssmac

                                                                                                 75
                                                Sovereign System

         (e) calculates the decryption as

                                                K = AESDecssenc (CTkey )

              and checks if
                                                         ?
                                                dkey = M ACssmac (CTkey )
              where ssenc ||ssmac = ss.

          (f ) calculates securityquestions = AESDecK (CTsq ).

         (g) answers the security questions. Let's say the answers are denoted as securityanswers
              2.

         (h) generates a fresh and new random value su and calculates

                         hashuprivateshare = su Ã‚Â· P oseidon(saltsecanswers , securityanswers).
          (i) sends (hashuprivateshare , Signeprivkeyrecover,jubjub (hashuprivateshare )) to the Producer.

 15. The Producer

         (a) veries Signeprivkeyrecover,jubjub (hashuprivateshare ) through epubkeyrecover,jubjub

         (b) sends (hashuprivateshare , Signeprivkeyrecover,jubjub (hashuprivateshare )) to Organizationi       Ã¢ÂˆÂ€
              i Ã¢ÂˆÂˆ Q.

 16. For k = j1 until jÃ¢Â„Â“ , Organizationk

         (a) veries Signeprivkeyrecover,jubjub (hashuprivateshare ) through epubkeyrecover,jubjub
                       Ã¢Â€Â²
         (b) computes h k = keyshareorg,i Ã‚Â· hashuprivateshare and creates a Schnorr proof
              (SchnorrProofOrg2k ) keyshareorg,i = logG
                                                              2
                                                                  pubshareorg,i = loghashuprivateshare hÃ¢Â€Â² k .
         (c) computes

                     SignatureÃ¢Â€Â²Ok = SignskOk (hÃ¢Â€Â² k , hash(usertotaldatau ), SchnorrProofOrg2k ).

                             Ã¢Â€Â²    Ã¢Â€Â²
         (d) sends (SignatureO , h k , hash(usertotaldatau ), SchnorrProofOrg2k ) to the Producer.
                                    k

 17. The Producer

         (a) veries SchnorrProofOrg2k for all k Ã¢ÂˆÂˆ Q.
                              Ã¢Â€Â²
         (b) veries SignatureO         for all k Ã¢ÂˆÂˆ Q.
                                    k

                          Ã¢Â€Â²
                                                  P       Ã¢Â€Â²
                                                                                        P         j
         (c) computes hashuprivateshare,O =   kÃ¢ÂˆÂˆQ ÃŽÂ»Q,k Ã‚Â· h k where ÃŽÂ»Q,k =                  jÃ¢ÂˆÂˆQ k jÃ¢ÂˆÂ’k denote the
              Lagrange coecients as in the Shamir's scheme.
                                                  Ã¢Â€Â²
         (d) forwards the nal computed value hashuprivateshare,O to the user.

 18. The user
     2 Note that these answers given must be the same as the ones created during the registration

76
                                                 Sovereign System

                                  Ã¢ÂˆÂ’1       Ã¢Â€Â²
      (a) computes committsku = su Ã‚Â· hashuprivateshare,O and creates a Schnorr proof
                                                                Ã¢ÂˆÂ’1
          (SchnorrProofRecover2) which proves the knowledge of su = loghÃ¢Â€Â²                 (committsku ).
                                                                          uprivateshare,O

      (b) sends committsku and SchnorrProofRecover2 to the Producer.

                                         Ã¢Â€Â²                                  Ã¢Â€Â²
 19. The Producer forwards committsku , hk , SchnorrProofRecover2, SignatureO to Organizationi
                                                                                              i
     Ã¢ÂˆÂ€i Ã¢ÂˆÂˆ Q.

 20. For k = j1 to jm , Organizationk

                       O,k
      (a) retrieves tskjubjub by decrypting the respective CTprivateshare,k included in the fetched
             DID document using skOk where skOk denotes the private key of Organizationk .

      (b) veries SchnorrProofRecover2
                            Ã¢Â€Â²
          (c) obtains committsku from DIDu
                           Ã¢Â€Â²
      (d) veries SignatureO           for all k = j1 , Ã‚Â· Ã‚Â· Ã‚Â· , jm .
                                   k

                                   ?       Ã¢Â€Â²
          (e) checks if committsku = committsku

          (f ) encrypts their partial private keys through epubkeyrecover,jubjub and sends back to the
             user. More concretely, each Organizationi computes

                                                                                 i 3
                                        Cshare,Oi = Encepubkeyrecover,jubjub (tskO )

     and sends Cshare,Oi to the Producer.

 21. The Producer sends Cshare,Ok back to the user for all k Ã¢ÂˆÂˆ Q.

 22. For k = j1 to jm , the user

      (a) calculates
                                            k
                                         tskO = Deceprivkeyrecover,jubjub (Cshare,Ok )
      (b) nally reconstructs the Trustible Private Key

                                                u,1                 u,mÃ¢ÂˆÂ’1              m              n 4
                     tskjubjub = Reconstruct(tskjubjub , Ã‚Â· Ã‚Â· Ã‚Â· , tskjubjub,secans , tskO , Ã‚Â· Ã‚Â· Ã‚Â· , tskO )

             through the Lagrange interpolation where
                               u
               i. calculate tskjubjub,secans = P BKDF 2(saltsecanswers , securityanswers)
                               u,i                  u
               ii. generate tskjubjub = P BKDF 2(tskjubjub,secans , i) for i = 1, Ã‚Â· Ã‚Â· Ã‚Â· , m Ã¢ÂˆÂ’ 1

 23. Once tsk (which is the constant term of the polynomial p(x)) is obtained, the user decrypts
                                                 u,i
     (CTseed , CTseed,key , dseed,key ) using tskjubjub and epubkeyseed .

   The user executes the protocol presented in Section                 ?? to obtain the private keys of other
chains.

  3 Note that this can be sent through the Producer since it is already encrypted).
  4 Any t values will be sucient to compute the polynomial p(x)

                                                                                                            77
                                               Sovereign System

Chapter 13
Integration of Trustible with PolygonID
In this chapter, we present a new protocol that lets Trustible users create their Polygon ID
through their Associated Accounts.           This allows Polygon ID to connect to the real identity
information, such as passports and id cards, via Trustible.

13.1 Creating a Claim for Polygon ID through Associated
     Accounts
Assumption 2. In the Polygon integration, Producer is assumed to be the Issuer.

     1. User

        (a) clicks on Polygon Integration in order to pull the actual data from IPFS using the
               main account (if not exists locally).

        (b) creates an associated account from the main account as:

                         skassociated,jubjub,i = P oseidon(tskjubjub , Ã¢Â€ÂœP olygonIDÃ¢Â€Â²Ã¢Â€Â² , i, random).
        (c)    identif ierpolygonid = P oseidon(tskjubjub , i)
        (d) calculates claim and hashpolygon based on hashu,selectivedisclosure where

                             hashu,selectivedisclosure = P oseidon(idcredentials, tskjubjub ).

                           Ã¢Â€Â²
        (e) calculates hashu,selectivedisclosure = P oseidon(randomnumber, hashu,selectivedisclosure ).

        (f ) creates ZKSNARK1 and ZKSNARK2 proving that the associated account has been
               calculated correctly and     hashu,selectivedisclosure is consistent with hashpolygon (e.g.,
               birthday and type of identity document could be public input for the proof ).
                               Ã¢Â€Â²
        (g) submits claim, hashu,selectivedisclosure , hashpolygon , ZKSNARK1 , ZKSNARK2 to Pro-
               ducer.

     2. Producer

78
                                               Sovereign System

     (a) veries ZKSNARK1 and ZKSNARK2 .

     (b) issues claim as in the Polygon ID ow (and the ow starting from here is exactly
            the same as in Polygon ID).

     (c) submits the following object DIDpolygonid to IPFS:

               i.  Sovereign
               ii. T rustible

             iii. ChainID

              iv. identif ierpolygonid

               v. pkassociated,jubjub,i
                        Ã¢Â€Â²
              vi. hashu,selectivedisclosure

             vii. claim

            viii. hashpolygon

              ix. random

               x. ZKSN ARK1

              xi. ZKSN ARK2

            xii. Merkle root of the DID Account Tree

     (d) computes CIDcoin = SHA256(DIDpolygonid ).

     (e) submits a transaction which contains (identif ierpolygonid , CIDpolygonid ) to the Algo-
            rand network. Let T xID be the transaction ID of the transaction.

     (f ) sends T xID to the user to ensure that the encryption has been processed successfully.

 3. The user veries the calculations.

13.1.1 ZKSNARK1
                  Ã¢Â€Â²
 1. Calculate hashu,selectivedisclosure = P oseidon(randomnumber, hashu,selectivedisclosure ) where
    randomnumber is a freshly generated random number.
                            Ã¢Â€Â²
 2. Given public values hashu,selectivedisclosure , pkassociated,jubjub,i , hashpolygon , random, identif ierpolygonid ,
    Merkle root of the DID Account tree and private values tpkjubjub , tskjubjub , skassociated,jubjub,i ,
    idcredentials, randomnumber, hashu,selectivedisclosure prove that
                        ?
     (a)    tpkjubjub = tskjubjub Ã‚Â· G2 .
     (b)    skassociated,jubjub,i = P oseidon(tskjubjub , Ã¢Â€ÂœP olygonIDÃ¢Â€Â²Ã¢Â€Â² , i, random).
                                  ?
     (c)    pkassociated,jubjub,i = skassociated,jubjub,i,random Ã‚Â· G2 .
     (d)    identif ierpolygonid = P oseidon(tskjubjub , i)
     (e)    hashÃ¢Â€Â²u,selectivedisclosure = P oseidon(randomnumber, P oseidon(idcredentials, tskjubjub )).
     (f )   (tpkjubjub , hashu,selectivedisclosure ) has an authentication path to Merkle root.

                                                                                                          79
                                              Sovereign System

13.1.2 ZKSNARK2
                        Ã¢Â€Â²
Given public values hashu,selectivedisclosure , hashpolygon , Merkle root of the DID Account Tree and
private values randomnumber , tskjubjub , idcredentials prove that

     1.   hashÃ¢Â€Â²u,selectivedisclosure = P oseidon(randomnumber, P oseidon(idcredentials, tskjubjub )).

     2.   hashÃ¢Â€Â²u,selectivedisclosure and hashpolygon are consistent. More concretely, the preimage of
          hashu,selectivedisclosure = P oseidon(idcredentials, tskjubjub ) contains the preimage of hashpolygon
          without disclosing hashu,selectivedisclosure .

80
                                        Sovereign System

Chapter 14
Restricting Associated Accounts for
Dierent Application Domains
In this chapter, we will limit users to have only one account per application domain.

14.1 A New Merkle Tree to Ensure One Associated Ac-
     count for Each Main Account
We want to link one associated account to each main account for a specic application do-
main, however we also want to keep the main account private.           To achieve this, we will
use a new Merkle tree that contains both the main account and the associated account, but
hides the main account from others.     More concretely, if a user creates a new associated ac-
count pkassociated,jubjub,chainid,appdomain,i for an Application Domain AppDomain on a chain (with
ChainID), then H(tskjubjub , ChainID, AppDomain) will be generated and will be added to
M erkleT reeappdomain unless it has been listed before. By doing this, we can ensure that every
main account has only one associated account per application domain.
   The Merkle tree of Application Domains in Figure 14.1 ensures that one single main account
cannot have more than one associated account for a given application domain.

14.2 The Protocol
  1. The user U

      (a) obtains the (identif ieru , CIDu ) from Algorand through tpked25519 .

      (b) nds and downloads the corresponding DID object DIDu from IPFS through CIDu .

       (c) selects an application domain AppDomain on a chain ChainID from the dropdown
           list of coins. Let's say the user selects AppDomain = PolygonID on Polygon.

      (d) computes    identif ierappdomain = P oseidon(tskjubjub , i) where i is an incremented
           number.

                                                                                               81
                                                 Sovereign System

Figure 14.1: M erkleT reeappdomain : The list of associated accounts and application domains
for a given main account where pkassociated,chainid,appdomain is the public key of an associated
account, Hashmainaccounttsk,chainid,appdomain is the hash of the private key of the corresponding
main account and the application domain AppDomain on a chain with ChainID .

                Remark. Note that identif ierappdomain should not be used before. To verify the
                uniqueness, the user rst checks whether it exists on the Algorand network.

         (e) computes

                skassociated,jubjub,chainid,appdomain,i = P oseidon(tskjubjub , ChainID, AppDomain, i, random)

                where random is a fresh random number.

          (f ) denes seed := skassociated,jubjub,chainid,appdomain,i .

         (g) computes the following:

            1           sk || y := sha512 . Sum512 ( seed )
            2           sk [0] &= 248
            3           sk [31] &= 127
            4           sk [31] |= 64
            5

         (h) calculates ÃŽÂ±i = sk       mod ord(ed25519) as in the standard reference implementation.
          (i) If ÃŽÂ±i is larger than the order of the subgroup for JubJub (i.e.,
                Ã¢Â„Â“= 2736030358979909402780800718157159386076813972158567259200215660948447373041),
                then start over with a new random seed to calculate the scalar (i.e., go to step 1e.) 1

          (j) calculates pkassociated,clamped,ed25519,chainid,appdomain,i = ÃŽÂ±i Ã‚Â· G1 .

         (k) calculates pkassociated,clamped,jubjub,chainid,appdomain,i = ÃŽÂ±i Ã‚Â· G2 .

     1 We need this step to make sure that the public keys generated on both curves have the same private keys.
See Section 5.8 for the reasoning of the calculations.

82
                                              Sovereign System

     (l) computes pkassociated,jubjub,chainid,appdomain,i = skassociated,jubjub,chainid,appdomain,i Ã‚Â· G2 .

    (m) obtains the most recent Merkle Root oldM erkleRoot from Algorand.

    (n) calculates Hashtsk,chainid,appdomain = P oseidon(tskjubjub , ChainID, AppDomain). 2

    (o) generates a ZKSN ARKassoc,merkle,chainid,appdomain which proves that
         pkassociated,jubjub,chainid,appdomain,i is linked to his/her main account tpkjubjub (=tskjubjub Ã‚Â·
         G1 ) without disclosing tpkjubjub and the main account is linked to M erkleT reeappdomain .
         More concretely, given public values newM erkleRoot, Hashtsk,chainid,appdomain ,
         pkassociated,jubjub,chainid,appdomain,i , identif ierappdomain , ChainID, AppDomain and private
         values i, tskjubjub , tpkjubjub , hashu,selectivedisclosure , random, skassociated,jubjub,appdomain,i ,
         (h1,internal , Ã‚Â· Ã‚Â· Ã‚Â· , hdepthÃ¢ÂˆÂ’1,internal ) 3 .
           procedure
           ZKSN ARKassoc,merkle,chainid,appdomain ((newM erkleRoot, pkassociated,jubjub,chainid,appdomain,i ),
           (tskjubjub , pskjubjub , skassociated,jubjub,chainid,appdomain,i , (h1,internal , Ã‚Â· Ã‚Â· Ã‚Â· , hdepthÃ¢ÂˆÂ’1,internal )) :)
                1) Check if identif ierappdomain = P oseidon(tskjubjub , i)
                2) Check if

            skassociated,jubjub,chainid,appdomain,i = P oseidon(tskjubjub , ChainID, AppDomain, i, random)

                                                                        ?
                3) Check if pkassociated,jubjub,chainid,appdomain,i = skassociated,jubjub,chainid,appdomain,i Ã‚Â·
            G2 .
                                      ?
                Check if tpkjubjub = tskjubjub Ã‚Â· G2 .
                                                    ?
                4) Hashtsk,ChainID,AppDomain = P oseidon(tskjubjub , ChainID, AppDomain).
               5) h0 Ã¢Â†Â (tpkjubjub , hashu,selectivedisclosure )
               for i = 1 till depth Ã¢ÂˆÂ’ 1 do
                  hi = hash(hiÃ¢ÂˆÂ’1 ||hi,internal )
               end for
                              ?
               6) Check if hi = newM erkleRoot
            end procedure
    (p) computes Comassociated,1,i,j          = ÃŽÂ±i,j Ã‚Â· G1 + sj Ã‚Â· H1 for some randomness sj where ÃŽÂ±i =
         ÃŽÂ±i,1 || Ã‚Â· Ã‚Â· Ã‚Â· ||ÃŽÂ±i,n with ÃŽÂ±i,j Ã¢ÂˆÂˆ {0, 1}, j = 1, Ã‚Â· Ã‚Â· Ã‚Â· , n.
    (q) computes Comassociated,2,i,j = ÃŽÂ±i,j Ã‚Â· G2 + tj Ã‚Â· H2 for some randomness tj .

     (r) creates a proof orProofGen as
         orProofGen((G1 , H1 , G2 , H2 , Comassociated,1,i,j , Comassociated,2,i,j ), (ÃŽÂ±i,j , sj , tj )).
                                        Pn jÃ¢ÂˆÂ’1
     (s) computes Comassociated,1,i =     1 2   Ã‚Â· Comassociated,1,i,j = ÃŽÂ±i Ã‚Â· G1 + s Ã‚Â· H1 .
                                        Pn jÃ¢ÂˆÂ’1
     (t) computes Comassociated,2,i =     1 2   Ã‚Â· Comassociated,2,i,j = ÃŽÂ±i Ã‚Â· G2 + t Ã‚Â· H2 .
    (u) creates a proof eqProofGen1 as
         eqProofGen((Comassociated,1,i , pkassociated,clamped,ed25519,chainid,appdomain,i ), s).
    (v) creates a proof eqProofGen2 as
         eqProofGen((Comassociated,2,i , pkassociated,clamped,jubjub,chainid,appdomain,i ), t).
2 This ensures the uniqueness of an associated accoount per main account.
3 These internal values can be taken from either onchain or ochain depending on the implementation.

                                                                                                                  83
                                                 Sovereign System

        (w) computes Signatureregistration = Signskassociated,jubjub,chainid,appdomain,i (data) where
             data = (pkassociated,clamped,jubjub,chainid,appdomain,i , pkassociated,clamped,ed25519,chainid,appdomain,i ,
             pkassociated,jubjub,chainid,appdomain,i , random, identif ierappdomain , ChainID, AppDomain,
             newM erkleRoot,
             Hashtsk,chainid,appdomain , Signatureassociatedaddress , ZKSN ARKassoc,merkle,chainid,appdomain ,
             pkassociated,clamped,ed25519,chainid,appdomain,i , orProofGen, eqProofGen1, eqProofGen2).
        (x) sends Signatureregistration , data to the Producer.

     2. The Producer

                                                          Ã¢Â€Â²
        (a) obtains the current Merkle root newM erkleRoot from Algorand.

        (b) veries Signatureregistration through pkassociated,jubjub,chainid,appdomain,i .
                                                                                 Ã¢Â€Â²
        (c) veries ZKSN ARKassoc,merkle,chainid,appdomain through newM erkleRoot ,
             Hashtsk,chainid,appdomain , pkassociated,jubjub,chainid,appdomain,i , random, identif ierappdomain ,
             ChainID and AppDomain.
        (d) checks if Hashtsk,chainid,appdomain exists in the Merkle tree of Application Domains
             which has the current root M erkleRootdomain,appdomain . It aborts the protocol if it
             already exists (to prevent multiple associated accounts for a given main account.).

        (e) veries orProofGen, eqProofGen1, eqProofGen2.

        (f ) submits the following object DIDappdomain to IPFS:

               i.  Sovereign
               ii. ChainID

             iii. AppDomain

              iv. newM erkleRoot

               v. identif ierappdomain

              vi. Hashtsk,chainid,appdomain

             vii. random

            viii. pkassociated,clamped,ed25519,chainid,appdomain,i

              ix. pkassociated,clamped,jubjub,chainid,appdomain,i

               x. ZKSN ARKassoc,merkle,chainid,appdomain

        (g) The Producer adds

             (pkassociated,jubjub,chainid,appdomain,i , Hashtsk,chainid,appdomain , ChainID, AppDomain) to
             M erkleT reeappdomain which is the Merkle root of the tree for all application do-
             mains. Let's say
             N ewM erkleRootappdomain is the new Merkle root of the tree N ewM erkleT reeappdomain .
        (h) computes CIDappdomain = SHA256(DIDappdomain ).

        (i) submits a transaction which contains (identif ierappdomain , pkassociated,jubjub,appdomain,i ,
             CIDappdomain ) to the Algorand network for pkassociated,clamped,ed25519,chainid,appdomain,i .
             Let T xID be the transaction ID of the transaction.

84
                                               Sovereign System

       (j) sends TxIDmerkle,chainid,appdomain , TxIDu back to the user to make ensure that the
           DID object DIDappdomain has been created successfully.

  3. The user veries if DIDappdomain has been indeed created and

                      ?
     CIDappdomain = Hash(DIDappdomain ) and (pkassociated,jubjub,chainid,appdomain,i , CIDappdomain )

     are stored in the given transaction through T xIDu for pkassociated,clamped,ed25519,chainid,appdomain,i .

14.3 Revoking an Associated Account for an Application
     Domain
To revoke an associated account that is linked to an app domain, users need to use the cor-
responding private key. Note that we can always recover the associated account because it is
derived from the main account, and the main account can always be restored as long as users
remember the answers to their security questions.

  1. The user calculates and sends

     Signskassociated,jubjub,chainid,appdomain,i (pkassociated,jubjub,chainid,appdomain,i , Hashtsk,chainid,appdomain , ChainID, A

     to the Producer.

  2. The Producer

      (a) nds a record using pkassociated,jubjub,chainid,appdomain,i in M erkleT reeappdomain .

      (b) removes (pkassociated,jubjub,chainid,appdomain,i , Hashtsk,chainid,appdomain , ChainID, AppDomain)
           from
           M erkleT reeappdomain .
      (c) updates the new Merkle root of M erkleT reeappdomain on the Algorand network.

      (d) stores

           Signskassociated,jubjub,chainid,appdomain,i (pkassociated,jubjub,chainid,appdomain,i , Hashtsk,chainid,appdomain , Chain

           on the Algorand network for public veriability.

      (e) noties the user about the removal.

                                                                                                                 85
                                            Sovereign System

Chapter 15
Deactivating Main Accounts

15.1 Case 1: If a user remembers his/her tsk
Assume that a user's main key has been compromised. In this case, the user needs to disable
the current main account and re-creates a new one.

     1. The user creates a signature using tsk and requests from the Producer to disable his/her
        corresponding main account.

     2. The signature is sent to the Producer.       Alternatively, it can also be submitted as a
        transaction (for public transparency).

     3. The Producer obtains the signature and veries its validity. If the verication is successful,
        then it disables the user. The disabling can be done in the following two ways:

         (a) Let's assume that (tpk, 1) and (tpk, 0) are used for enabled and disabled users, re-
             spectively. We store (tpk, 1) in the Merkle tree instead of having only tpk . If a user
             requests to be disabled then (tpk, 1) will be updated to (tpk, 0), and the Merkle root
             will be updated accordingly.

        (b) We can also simply remove tpk from the leaves and update the Merkle root accord-
             ingly.

Remark. Once users are disabled, they will not be able to use any Vendible services since a
valid proof cannot be generated any more.

Remark. Once users are disabled, they have to perform the registration process again to be
able to create new tpk .

15.2 Case 2: If a user does not remember both tsk and the
     security answers
In this case, the removal cannot be processed. The reason is that the Sovereign system does
not hold any relation between the identifying information and tpk , and therefore, the Sovereign
system cannot verify whether the user is telling the truth.

86
                                         Sovereign System

Chapter 16
Potential Enhancements: Extending to
Social Recovery
The Sovereign System can also easily be extended to support social recovery. Namely, the user
can add his/her additional public keys of his friends or family members to be part of the system.
The Producer will reduce the number of public keys from the number of the organizations and
only share with the remaining number of the organizations. In this way, the system could be
more exible.
   For example, during the registration, let's say a user Alice also shares the public key of her
father Bob, her aunt Eve, and her close friend Charlie, and also asked to have (4,7) threshold
security in the system. hence,

   Ã‚Âˆ skalice (her private key share through security questions)

   Ã‚Âˆ skbob (her father's private key)

   Ã‚Âˆ skeve (her aunt's private key)

   Ã‚Âˆ skcharlie (her close friend's private key)

   Ã‚Âˆ Organization1 , Organization2 , Organization3 ,

   Based on this construction, we can conclude the followings:

   Ã‚Âˆ The system can be robust up-to three participants' corruption (e.g., system failures or
     key loss).

   Ã‚Âˆ The Sovereign System remains intact (i.e., the Producer colluding with the Organizations
     maliciously cannot obtain the private key at all (including brute force attacks)) as three
     organizations is strictly less than the threshold. Namely, the organizations are required
     to collude with at least one party to apply brute force attacks.

   Ã‚Âˆ Alice does not need the Organizations to recover her keys.         Namely, the keys can be
     recovered even if the Sovereign System is corrupted (or down) including the Organizations
     ability to operate.

                                                                                              87
                                        Sovereign System

Chapter 17
Securing the Sovereign System
The Sovereign System, having a separate elliptic curve that equates to private keys on all signif-
icant blockchains, coupled with the assurance that each participant is a unique Member, opens
the possibility for a cross-chain identity network that operates as a trust layer for distributed
ledgers.
     To secure the network, we propose a cooperative network model which includes a digital
asset (or token), dA. The token dA provides a measure of each Member's impact on the network,
rewards Members for positive support, acts as a deterrent for Members who might otherwise
abuse the system or other Members, and helps facilitate network governance.

17.1 Network Minimum Commitment
Each Member has a Main Account which contains the DID object that attests to their unique-
ness on the network.   This Main Account has one purpose outside of maintaining the DID;
acting as the signatory in the construction of Associated Accounts. It is advisable to create an
Associated Account for each connection made by the Member to help preserve the privacy of
each Member. A connection is a channel formed between two Members to transfer data and
assets between one another.    These connections exist between contacts (friends and family),
merchants, decentralized applications (dApps), and institutions. The rst step in securing the
network is to leverage the creation of Associated Accounts so that Members have a veriable
measure of their network activity. A small amount of dA (with the amount dependent upon
the use case) can lock into each Associated Account upon creation.       This dA is paid for by
the Member or a Service Provider acting on behalf of the Member. This commitment stake
remains in the Associated Account until a vesting period expires or that account is no longer
in use. The network minimum commitment is the sum of a Member's dA held in Associated
Accounts.

17.2 Cooperative Network
The Minimum Commitment is an incentive to reward behavior that benets the long-term
health of the network. We employ a stake-and-slash mechanism managed by a decentralized

88
                                        Sovereign System

autonomous organization (DAO) to help oversee the direct operation of the network.           All
Members have the right to privacy and the freedom to steward their data and assets without
interference from outside parties. However, if a Member (whether that Member is an individual,
business, Service Provider, Organization, Validator, the DAO Foundation or Producer) acts
maliciously or counter to the viable operation of the network, they can lose their Minimum
Commitment stake and, in some instances, the right to operate on the network.           In some
variations, the Member can also give up their right to privacy as a direct result of malicious
actions.   Conversely, members can gain rewards through multiple mechanisms, including the
distribution of dA, for activities that support the operation of the network. Participation is
the term used for supportive network activities.

17.3 Member Staking
Members may stake dA above the Minimum Commitment. A specic Associated Account holds
the stake.   Staking provides access to community management of the cooperative network,
oversight of the community treasury, voting and administration for Foundation representatives,
and direct network rewards.

17.4 Operational Rewards
Suppose the cooperative network generates value from the specic properties of the network
(i.e., Service Providers nd value in building products that leverage veriable claims of unique-
ness and secure data management).      In that case, network Members can share in this value
generation. A separate paper will outline specics on reward distributions by the Producer to
Members based on network activity and staking.

                                                                                              89
                                         Sovereign System

Chapter 18
Expansion of the Sovereign System
The Sovereign System outlined in the paper is an open framework for identity, data, privacy,
and payment solutions. Additional research and publications will add to this body of work. An
outline of upcoming and future expansion follows.

18.1 Identity Vault Questions Research
In a fully Sovereign System, the security and recovery of a Member's Main Account are pred-
icated on the Member remembering the questions.         A large body of research has examined
various methods for secure fallback authentication. The authors have compiled much of this
research and will apply these topics to early testing of Main Account generation. Questions
must be memorable but not easily guessed. Testing dierent question modes, including text,
visual, kinetic, persona, location-based, and specic recall prompts, will help ensure a robust
system. We will explore further variations of account setup with fail-safe options for Members.
Upon completion of testing, we will publish our results to guide best practices.

18.2 Selective Disclosure and User-Owned Distributed Data
One of the most powerful aspects of the Sovereign System is that through Associated Accounts,
Service Providers, Institutions, and Organizations can query the Member without the Member
revealing any personal information. Leveraging the Merkle Tree setup, a Member can generate
an Associated Account for authentication, and outside parties can pose zero-knowledge-based
questions to the Associated Accounts and receive answers from the Main Account without
exposing the public address of the Main Account.
     Service Providers can use the Associated Accounts and the veriable uniqueness of Members
to build new classes of applications.   Some advantages of this authentication system include
preventing bots from gaining access, restrictions to admittance based on age or geography, and
ensuring that each user in an application can only create one account in a system.
     All data produced in the Sovereign System is encrypted, stored in a distributed manner
to ensure availability, and attributed to DIDs (both in the Main Account and Associated
Accounts). The Member entirely owns this data. The Member can selectively share this data

90
                                          Sovereign System

with other Members or service providers. Service Providers can create custom data attributes
for their applications and leverage the Sovereign System to store and manage user-owned data
securely. In this scenario, a user will agree to share specic data attributes created or named
by the Service Provider before gaining access to an application. If the Member no longer wishes
to interact with the application, they can revoke the Service Providers' access to their data.

18.3 Automation of Associated Accounts
Returning to the VAM adoption model, applications utilizing the Sovereign System must ensure
that the benets of engaging with the technology outweigh any perceived sacrices. The system
must be enjoyable to use with little monetary and mental costs.      Automation of Associated
Accounts will help provide the most value for the eort. With all accounts recoverable through
the Main Account, it is advisable to create user experiences that obfuscate the entire key
generation and management process so that the Member can interact with the technology in
ways they are already familiar [Lin98].
   A paper outlining best account generation and management practices across multiple net-
works and applications will help guide this area.

18.4 Specic Use Cases
During the creation of the Sovereign System, multiple use cases were proposed, outlined, and
designed to ensure the robustness of the proposed system. Numerous papers will outline each
use case and its potential impact on the market. Use cases explored include:

   Ã‚Âˆ anonymous polling and voting

   Ã‚Âˆ authentication techniques

   Ã‚Âˆ anonymous KYC and ongoing AML

   Ã‚Âˆ user-disclosed KYC data and ongoing AML

   Ã‚Âˆ user-owned decentralized data storage

   Ã‚Âˆ single-sign-on systems

   Ã‚Âˆ privacy-preserving markets

   Ã‚Âˆ condential transactions

   Ã‚Âˆ compliant-condential transactions

                                                                                             91
                                         Sovereign System

18.5 Variations of the Sovereign System
The Sovereign System is the base layer of an open solution for identity, data protection, and
payments. The base layer design is structured to guide the Early Majority, Late Majority, and
Laggards (consisting of individuals, businesses, and institutions) to accept self-custody of their
data and assets as the de facto mode of transaction across the internet.      Organizations and
Service Providers can extend the use of the system to t their specic use cases.
     The rst notable extensions are user-provisioned data so application developers can choose
to build systems where data is user-owned and stored in a distributed manner with no central
point of failure.   Adopting this setup will shift data storage for centralized data centers and
cloud infrastructure to lower-cost options with the added benet of reducing the chance of data
hacks and leaks as data duplication is unnecessary.
     The second notable extension is dierent threshold setups for organizations to comply with
nancial regulations and required reporting. Users can opt into dierent key-share congura-
tions to ensure that BSA, travel rules, central banking practices, and government-mandated
disclosures.   The user can manage this process rather than external service providers.      This
compliant setup keeps the user in complete control of their identity, data, and privacy while
continuing to use desired or required services.

92
                                       Sovereign System

Bibliography
[AFH20]    N. Sullivan R.S. Wahby A. Faz-Hernandez, S. Scott,       Hashing to Elliptic Curves
           draft-irtf-cfrg-hash-to-curve-06), Internet Draft, March 2020.
    +
[AGR 16]   Martin Albrecht, Lorenzo Grassi, Christian Rechberger, Arnab Roy, and Tyge
           Tiessen,  Mimc: Ecient encryption and cryptographic hashing with minimal mul-
           tiplicative complexity, Advances in Cryptology  ASIACRYPT 2016 (Berlin, Hei-
           delberg), Springer Berlin Heidelberg, 2016, pp. 191219.

[BD18]     Razvan Barbulescu and Sylvain Duquesne,        Updating key size estimations for pair-
           ings, Journal of Cryptology (2018).
[Con22]    World Wide Web Consortium,      Decentralized identiers (dids) v1.0 core architec-
           ture, data model, and representations, https://www.w3.org/TR/did-core/.
[Cra20]    Jake Craige,   An explainer on ed25519 clamping, July 2020, https://www.jcraige.
           com/an-explainer-on-ed25519-clamping.

[FP18]     FIPS-PUB-202,     SHA-3 Standard: Permutation-Based Hash and Extendable-Output
           Functions,      https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf,
           2018.

[Gar22]           Gartner 2019 Hype Cycle for Blockchain Business Shows Blockchain Will
           Gartner,
           Have a Transformational Impact across Industries in Five to 10 Years, 2022,
           12.12.2022.

[GJ20]     Kobi Gurkan and Koh Wei Jie,    Community Proposal: Semaphore: Zero-Knowledge
           Signaling on Ethereum, 2020, 12.12.2022.
[GKR04]    Rosario Gennaro, Hugo Krawczyk, and Tal Rabin,           Secure hashed die-hellman
           over non-ddh groups, Advances in Cryptology - EUROCRYPT 2004 (Berlin, Hei-
           delberg), Springer Berlin Heidelberg, 2004, pp. 361381.

    +
[GKR 21]   Lorenzo Grassi, Dmitry Khovratovich, Christian Rechberger, Arnab Roy, and
           Markus Schofnegger,    Poseidon: A new hash function for Zero-Knowledge proof
           systems, 30th USENIX Security Symposium (USENIX Security 21), USENIX As-
           sociation, August 2021, pp. 519535.

                                                                                              93
                                       Sovereign System

[HD08]    Wong K. Carter G. Hisil, H. and E. Dawson,     Extended coordinates with a=-1
          for twisted Edwards curves", The 'add-2008-hwcd-3' addition formulas, December
          2008.

[Hr11]    Tony Hansen and Donald E. Eastlake 3rd,         US Secure Hash Algorithms (SHA and
          SHA-based HMAC and HKDF), RFC 6234, May 2011.
[HWCD08] Huseyin Hisil, Kenneth Koon-Ho Wong, Gary Carter, and Ed Dawson,               Twisted
          edwards curves revisited, Advances in Cryptology - ASIACRYPT 2008 (Berlin,
          Heidelberg), Springer Berlin Heidelberg, 2008, pp. 326343.

[IEE13]   IEEE standard for identity-based cryptographic techniques using pairings, IEEE Std
          1363.3-2013 (2013), 1151.

[JL17]    Simon Josefsson and Ilari Liusvaara,    Edwards-Curve Digital Signature Algorithm
          (EdDSA), RFC 8032, January 2017.
[KH20]    Rafael Schultze-Kraft Kilian Heeg,    78 percent of the bitcoin supply is not liquid,
          https://insights.glassnode.com/bitcoin-liquid-supply/.

[Kho19]   Dmitry Khovratovich,    Encryption with poseidon, Dec 2019, https://drive.
          google.com/file/d/1EVrP3DzoGbmzkRmYnyEDcIQcXVU7GlOd/view?pli=1.
[Lam22]   Alessandro Lampo,   How is technology accepted? fundamental works in user tech-
          nology acceptance from diusion of innovations to utaut-2.
[LHT16]   Adam Langley, Mike Hamburg, and Sean Turner,         Elliptic Curves for Security, RFC
          7748, January 2016.

[Lin98]   Carolyn Lin,   Exploring personal computer adoption dynamics, Journal of Broad-
          casting & Electronic Media - J BROADCAST ELECTRON MEDIA                    42 (1998),
          95112.

[Men18]   Ingo & Aalst Wil & Brocke Jan vom & Cabanillas Cristina & Daniel Florian &
          Debois SÃƒÂ¸ren & Di Ciccio Claudio & Dumas Marlon & Dustdar Schahram & Gal
          Avigdor & GarcÃƒÂ­a-BaÃƒÂ±uelos Luciano & Governatori Guido & Hull Richard & La
          Rosa Marcello & Leopold Henrik & Leymann Frank & Recker Jan & Reichert
          Manfred & Zhu Liming Mendling, Jan & Weber,         Blockchains for business pro-
          cess management - challenges and opportunities. acm transactions on management
          information systems., In press, accepted. 10.1145/3183367.
[Moo22]   Georey Moore, Crossing the chasm : Marketing and selling disruptive products to
          mainstream customers., 2022, Rev. ed. HarperBusiness Essentials.
[MSS17]   Alfred Menezes, Palash Sarkar, and Shashank Singh,  Challenges with assessing the
          impact of nfs advances on the security of pairing-based cryptography, Paradigms
          in Cryptology  Mycrypt 2016. Malicious and Exploratory Cryptology (Cham),
          Springer International Publishing, 2017, pp. 83108.

94
                                        Sovereign System

[Nak08]   S.   Nakamoto,         Bitcoin:      A    peer-to-peer   electronic   cash   system.,
          https://bitcoin.org/bitcoin.pdf.

[Res10]   Certicom Research,      SEC 2: Recommended Elliptic Curve Domain Parameters,
          Standards for Ecient Cryptography, 2010.

[Rog]     Everett M. Rogers,      Diusion of Innovations: An Overview, Use and Impact of
          Computers in Clinical Medicine (James G. Anderson and Stephen J. Jay, eds.),
          Computers and Medicine, Springer, pp. 113131.

[Rog79]   Everett M Rogers,      Network analysis of the diusion of innovations, Perspectives
          on social network research, Elsevier, 1979, pp. 137164.

[Rog03]   Everett M. Rogers,      Diusion of innovations, 5th ed., Free Press, New York, NY
          [u.a.], 08 2003.

[Rog10]   E.M. Rogers,     Diusion of innovations, 4th edition, Free Press, 2010.
[RS71]    Everett M. Rogers and F. Floyd Shoemaker,         Communication of innovations: A
          cross-cultural approach, 2nd ed., 1971.
[RSF07]   Alastair Robertson, Didier Soopramanien, and Robert Fildes, Household technol-
          ogy acceptance heterogeneity in computer adoption, Department of Management
          Science, Lancaster University, Working Papers (2007).

[Sch22]   Berry Schoenmakers,       Lecture notes on cryptographic protocols, February 2022,
          https://www.win.tue.nl/ berry/CryptographicProtocols/LectureNotes.pdf.

[sem22]   Semaphore: Signal anonymously, August 2022, https://semaphore.appliedzkp.
          org/.
[Wis22]   Crypto Wisser,     Exchange graveyard, 2022, https://www.cryptowisser.com/exchange-
          graveyard/.

[ZCa17]   ZCash,   What is jubjub, 2017, https://z.cash/technology/jubjub/.
[ZCa21]            ,   Zcash protocol specication, February 2021, https://github.com/zcash/
          zips/blob/master/protocol/protocol.pdf.

                                                                                            95